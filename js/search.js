// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "howitworks",
      "url": "/treadle/HowItWorks.html",
      "content": "How it works Treadle ingests a single FIRRTL file runs a few FIRRTL transforms on it and constructs a symbol table and a program. The program is nothing more than a complete list of simple assignments topologically sorted so as single pass of the program will completely update the circuit. Treadle has a number of useful capabilities. Many of which are not accessible through the standard PeekPoke interface exposed by the chisel unit testesrs. All signals and memories and accessible for peeking Arbitrary wires can be forced to a particular value Verbose modes can show every circuit operation A data plugin facility gives developers the ability hooks to monitor every individual assignement statement The VCD output facility is implemented via this plugin architecture Tracing individual assignments and showing their driving inputs is another example An DataCollector example that monitors the highest and lowest values recorded on each wire is provided in the tests Direct access to one or more clocks and the ability to manually advance wall time is provided. Relatively untried capability to allow rollback in time is present A Scala based black box facility provides a mechanism for developers to model external verilog functions Treadle cannot otherwise process external verilog black boxes Register Handling Clock Special Handling Memory implementation VCD processing"
    } ,    
    {
      "title": "treadlerepl",
      "url": "/treadle/TreadleRepl.html",
      "content": "TreadleRepl The TreadleRepl is a character based debug facility for firrtl circuits. It has a host of features that let a user manual peek and poke values, advance the clock and set monitoring in a number of ways. Launching The TreadleRepl can be launched from a terminal session by running the ./treadle.sh script. To launch it for a local firrtl file myfile.fir use: ./treadle.sh -frfs myfile.fir Faster launching The above script uses sbt to run and that can be a bit slow to start up. You can build a executable jar for the TreadleRepl by executing sbt assembly This will create an executable jar in the utils/bin directory. In that directory there is a script treadle that will launch that jar. You can copy both the jar and script to your own local bin or make symbolic links to it. Command line options There are many command line options available to see them all, add –help to the command line. The Repl commands To get started at the prompt type the help command to see what the other commands are. Currently the commands are command description load fileName load/replace the current firrtl file script fileName load a script from a text file run [linesToRun|all|list|reset] run loaded script vcd [load|run|list|test|help] control vcd input file record-vcd [&lt;fileName&lt;]|[done] treadle.vcd loaded script symbol regex show symbol information watch [+|-] regex [regex …] watch (+) or unwatch (-) signals poke inputSymbol value set an input port to the given integer value force symbol value hold a wire to value (use value clear to clear forced wire) rpoke regex value poke value into portSymbols that match regex peek symbol [offset] show the current value of the signal rpeek regex show the current value of symbols matching the regex randomize randomize all symbols except reset) reset [numberOfSteps] assert reset (if present) for numberOfSteps (default 1) reset [b|d|x|h] Set the output radix to binary, decimal, or hex step [numberOfSteps] cycle the clock numberOfSteps (default 1) times, and show state waitfor symbol value [maxNumberOfSteps] wait for particular value (default 1) of symbol, up to maxNumberOfSteps (default 100) depend [childrenOf|parentsOf] signal [depth] | depend compare symbol1 symbol2 show dependency relationship to symbol or between two symbols show [state|inputs|outputs|clocks|firrtl|lofirrtl] show useful things display symbol[, symbol, …] show computation of symbols info show information about the circuit walltime [advance] show current wall time, or advance it verbose [true|false|toggle] set evaluator verbose mode (default toggle) during dependency evaluation snapshot save state of engine restore restore state of engine from snapshot file waves symbolName … generate wavedrom json for viewing waveforms history [pattern] show command history, with optional regex pattern help [markdown] show repl commands (in markdown format if desired) quit exit the engine"
    } ,    
    {
      "title": "Annotations",
      "url": "/chisel3/docs/explanations/annotations.html",
      "content": "Annotations Annotations are metadata containers associated with zero or more “things” in a FIRRTL circuit. Commonly, Annotations are used to communicate information from Chisel to a specific, custom FIRRTL Transform. In this way Annotations can be viewed as the “arguments” that a specific Transform consumes. This article focuses on the approach to building a basic library that contains Annotations and Transforms. Imports We need a few basic imports to reference the components we need. import chisel3._ import chisel3.experimental.{annotate, ChiselAnnotation, RunFirrtlTransform} import chisel3.internal.InstanceId import firrtl._ import firrtl.annotations.{Annotation, SingleTargetAnnotation} import firrtl.annotations.{CircuitTarget, ModuleTarget, InstanceTarget, ReferenceTarget, Target} Define an Annotation and a Transform First, define an Annotation that contains a string associated with a Target thing in the Chisel circuit. This InfoAnnotation extends SingleTargetAnnotation, an Annotation associated with one thing in a FIRRTL circuit: /** An annotation that contains some string information */ case class InfoAnnotation(target: Target, info: String) extends SingleTargetAnnotation[Target] { def duplicate(newTarget: Target) = this.copy(target = newTarget) } Second, define a Transform that consumes this InfoAnnotation. This InfoTransform simply reads all annotations, prints any InfoAnnotations it finds, and removes them. /** A transform that reads InfoAnnotations and prints information about them */ class InfoTransform() extends Transform with DependencyAPIMigration { override def prerequisites = firrtl.stage.Forms.HighForm override def execute(state: CircuitState): CircuitState = { println(\"Starting transform 'IdentityTransform'\") val annotationsx = state.annotations.flatMap{ case InfoAnnotation(a: CircuitTarget, info) =&gt; println(s\" - Circuit '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: ModuleTarget, info) =&gt; println(s\" - Module '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: InstanceTarget, info) =&gt; println(s\" - Instance '${a.serialize}' annotated with '$info'\") None case InfoAnnotation(a: ReferenceTarget, info) =&gt; println(s\" - Component '${a.serialize} annotated with '$info''\") None case a =&gt; Some(a) } state.copy(annotations = annotationsx) } } Note: inputForm and outputForm will be deprecated in favor of a new dependency API that allows transforms to specify their dependencies more specifically than with circuit forms. Full backwards compatibility for inputForm and outputForm will be maintained, however. Create a Chisel API/Annotator Now, define a Chisel API to annotate Chisel things with this InfoAnnotation. This is commonly referred to as an “annotator”. Here, define an object, InfoAnnotator with a method info that generates InfoAnnotations. This uses the chisel3.experimental.annotate passed an anonymous ChiselAnnotation object. The need for this ChiselAnnotation (which is different from an actual FIRRTL Annotation) is that no FIRRTL circuit exists at the time the info method is called. This is delaying the generation of the InfoAnnotation until the full circuit is available. This annotator also mixes in the RunFirrtlTransform trait (abstract in the transformClass method) because this annotator, whenever used, should result in the FIRRTL compiler running the custom InfoTransform. object InfoAnnotator { def info(component: InstanceId, info: String): Unit = { annotate(new ChiselAnnotation with RunFirrtlTransform { def toFirrtl: Annotation = InfoAnnotation(component.toTarget, info) def transformClass = classOf[InfoTransform] }) } } Note: there are a number of different approaches to writing an annotator. You could use a trait that you mix into a Module, an object (like is done above), or any other software approach. The specific choice of how you implement this is up to you! Using the Chisel API Now, we can use the method InfoAnnotation.info to create annotations that associate strings with specific things in a FIRRTL circuit. Below is a Chisel Module, ModC, where both the actual module is annotated as well as an output. class ModC(widthC: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(widthC.W)) val out = Output(UInt(widthC.W)) }) io.out := io.in InfoAnnotator.info(this, s\"ModC($widthC)\") InfoAnnotator.info(io.out, s\"ModC(ignore param)\") } Running the Compilation Compiling this circuit to Verilog will then result in the InfoTransform running and the added printlns showing information about the components annotated. import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation} (new ChiselStage).execute(Array.empty, Seq(ChiselGeneratorAnnotation(() =&gt; new ModC(4))))"
    } ,      
    {
      "title": "Appendix",
      "url": "/chisel3/docs/appendix/appendix.html",
      "content": "Appendix This section covers some less-common Chisel topics. Differences between Chisel3 and Chisel2 Experimental Features Upgrading from Scala 2.11 Versioning"
    } ,    
    {
      "title": "Blackboxes",
      "url": "/chisel3/docs/explanations/blackboxes.html",
      "content": "Chisel BlackBoxes are used to instantiate externally defined modules. This construct is useful for hardware constructs that cannot be described in Chisel and for connecting to FPGA or other IP not defined in Chisel. Modules defined as a BlackBox will be instantiated in the generated Verilog, but no code will be generated to define the behavior of module. Unlike Module, BlackBox has no implicit clock and reset. BlackBox’s clock and reset ports must be explicitly declared and connected to input signals. Ports declared in the IO Bundle will be generated with the requested name (ie. no preceding io_). Parameterization Verilog parameters can be passed as an argument to the BlackBox constructor. For example, consider instantiating a Xilinx differential clock buffer (IBUFDS) in a Chisel design: import chisel3._ import chisel3.util._ import chisel3.experimental._ // To enable experimental features class IBUFDS extends BlackBox(Map(\"DIFF_TERM\" -&gt; \"TRUE\", \"IOSTANDARD\" -&gt; \"DEFAULT\")) { val io = IO(new Bundle { val O = Output(Clock()) val I = Input(Clock()) val IB = Input(Clock()) }) } class Top extends Module { val io = IO(new Bundle {}) val ibufds = Module(new IBUFDS) // connecting one of IBUFDS's input clock ports to Top's clock signal ibufds.io.I := clock } In the Chisel-generated Verilog code, IBUFDS will be instantiated as: IBUFDS #(.DIFF_TERM(\"TRUE\"), .IOSTANDARD(\"DEFAULT\")) ibufds ( .IB(ibufds_IB), .I(ibufds_I), .O(ibufds_O) ); Providing Implementations for Blackboxes Chisel provides the following ways of delivering the code underlying the blackbox. Consider the following blackbox that adds two real numbers together. The numbers are represented in chisel3 as 64-bit unsigned integers. import chisel3._ class BlackBoxRealAdd extends BlackBox { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) } The implementation is described by the following verilog module BlackBoxRealAdd( input [63:0] in1, input [63:0] in2, output reg [63:0] out ); always @* begin out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2)); end endmodule Blackboxes with Verilog in a Resource File In order to deliver the verilog snippet above to the backend simulator, chisel3 provides the following tools based on the chisel/firrtl annotation system. Add the trait HasBlackBoxResource to the declaration, and then call a function in the body to say where the system can find the verilog. The Module now looks like import chisel3._ import chisel3.util.HasBlackBoxResource class BlackBoxRealAdd extends BlackBox with HasBlackBoxResource { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) addResource(\"/real_math.v\") } The verilog snippet above gets put into a resource file names real_math.v. What is a resource file? It comes from a java convention of keeping files in a project that are automatically included in library distributions. In a typical chisel3 project, see chisel-template, this would be a directory in the source hierarchy: src/main/resources/real_math.v. Blackboxes with In-line Verilog It is also possible to place this verilog directly in the scala source. Instead of HasBlackBoxResource use HasBlackBoxInline and instead of setResource use setInline. The code will look like this. import chisel3._ import chisel3.util.HasBlackBoxInline class BlackBoxRealAdd extends BlackBox with HasBlackBoxInline { val io = IO(new Bundle { val in1 = Input(UInt(64.W)) val in2 = Input(UInt(64.W)) val out = Output(UInt(64.W)) }) setInline(\"BlackBoxRealAdd.v\", \"\"\"module BlackBoxRealAdd( | input [15:0] in1, | input [15:0] in2, | output [15:0] out |); |always @* begin | out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2)); |end |endmodule \"\"\".stripMargin) } This technique will copy the inline verilog into the target directory under the name BlackBoxRealAdd.v Under the Hood This mechanism of delivering verilog content to the testing backends is implemented via chisel/firrtl annotations. The two methods, inline and resource, are two kinds of annotations that are created via the setInline and setResource methods calls. Those annotations are passed through to the chisel-testers which in turn passes them on to firrtl. The default firrtl verilog compilers have a pass that detects the annotations and moves the files or inline test into the build directory. For each unique file added, the transform adds a line to a file black_box_verilog_files.f, this file is added to the command line constructed for verilator or vcs to inform them where to look. The dsptools project is a good example of using this feature to build a real number simulation tester based on black boxes. The interpreter Note that the FIRRTL Interpreter is deprecated. Please use Treadle, the new Chisel/FIRRTL simulator The firrtl interpreter uses a separate system that allows users to construct scala implementations of the black boxes. The scala implementation code built into a BlackBoxFactory which is passed down to the interpreter by the execution harness. The interpreter is a scala simulation tester. Once again the dsptools project uses this mechanism and is a good place to look at it. It is planned that the BlackBoxFactory will be replaced by integration with the annotation based blackbox methods stuff soon."
    } ,    
    {
      "title": "Bundles and Vecs",
      "url": "/chisel3/docs/explanations/bundles-and-vecs.html",
      "content": "Bundle and Vec are classes that allow the user to expand the set of Chisel datatypes with aggregates of other types. Bundles group together several named fields of potentially different types into a coherent unit, much like a struct in C. Users define their own bundles by defining a class as a subclass of Bundle. import chisel3._ class MyFloat extends Bundle { val sign = Bool() val exponent = UInt(8.W) val significand = UInt(23.W) } class ModuleWithFloatWire extends RawModule { val x = Wire(new MyFloat) val xs = x.sign } You can create literal Bundles using the experimental Bundle Literals feature. Scala convention is to name classes using UpperCamelCase, and we suggest you follow that convention in your Chisel code. Vecs create an indexable vector of elements, and are constructed as follows: class ModuleWithVec extends RawModule { // Vector of 5 23-bit signed integers. val myVec = Wire(Vec(5, SInt(23.W))) // Connect to one element of vector. val reg3 = myVec(3) } (Note that we specify the number followed by the type of the Vec elements. We also specifiy the width of the SInt) The set of primitive classes (SInt, UInt, and Bool) plus the aggregate classes (Bundles and Vecs) all inherit from a common superclass, Data. Every object that ultimately inherits from Data can be represented as a bit vector in a hardware design. Bundles and Vecs can be arbitrarily nested to build complex data structures: class BigBundle extends Bundle { // Vector of 5 23-bit signed integers. val myVec = Vec(5, SInt(23.W)) val flag = Bool() // Previously defined bundle. val f = new MyFloat } Note that the builtin Chisel primitive and aggregate classes do not require the new when creating an instance, whereas new user datatypes will. A Scala apply constructor can be defined so that a user datatype also does not require new, as described in Function Constructor. Flipping Bundles The Flipped() function recursively flips all elements in a Bundle/Record. This is very useful for building bidirectional interfaces that connect to each other (e.g. Decoupled). See below for an example. class ABBundle extends Bundle { val a = Input(Bool()) val b = Output(Bool()) } class MyFlippedModule extends RawModule { // Normal instantiation of the bundle // 'a' is an Input and 'b' is an Output val normalBundle = IO(new ABBundle) normalBundle.b := normalBundle.a // Flipped recursively flips the direction of all Bundle fields // Now 'a' is an Output and 'b' is an Input val flippedBundle = IO(Flipped(new ABBundle)) flippedBundle.a := flippedBundle.b } This generates the following Verilog: module MyFlippedModule( input normalBundle_a, output normalBundle_b, output flippedBundle_a, input flippedBundle_b ); assign normalBundle_b = normalBundle_a; // @[bundles-and-vecs.md 61:18] assign flippedBundle_a = flippedBundle_b; // @[bundles-and-vecs.md 66:19] endmodule MixedVec (Chisel 3.2+) All elements of a Vec must be of the same type. If we want to create a Vec where the elements have different types, we can use a MixedVec: import chisel3.util.MixedVec class ModuleMixedVec extends Module { val io = IO(new Bundle { val x = Input(UInt(3.W)) val y = Input(UInt(10.W)) val vec = Output(MixedVec(UInt(3.W), UInt(10.W))) }) io.vec(0) := io.x io.vec(1) := io.y } We can also programmatically create the types in a MixedVec: class ModuleProgrammaticMixedVec(x: Int, y: Int) extends Module { val io = IO(new Bundle { val vec = Input(MixedVec((x to y) map { i =&gt; UInt(i.W) })) // ... }) // ...rest of the module goes here... } A note on cloneType Since Chisel is built on top of Scala and the JVM, it needs to know how to construct copies of bundles for various purposes (creating wires, IOs, etc). If you have a parametrized bundle and Chisel can’t automatically figure out how to clone your bundle, you will need to create a custom cloneType method in your bundle. Most of the time, this is as simple as override def cloneType = (new YourBundleHere(...)).asInstanceOf[this.type]. Note that in the vast majority of cases, this is not required as Chisel can figure out how to clone most bundles automatically. Here is an example of a parametrized bundle (ExampleBundle) that features a custom cloneType. class ExampleBundle(a: Int, b: Int) extends Bundle { val foo = UInt(a.W) val bar = UInt(b.W) override def cloneType = (new ExampleBundle(a, b)).asInstanceOf[this.type] } class ExampleBundleModule(btype: ExampleBundle) extends Module { val io = IO(new Bundle { val out = Output(UInt(32.W)) val b = Input(chiselTypeOf(btype)) }) io.out := io.b.foo + io.b.bar } class Top extends Module { val io = IO(new Bundle { val out = Output(UInt(32.W)) val in = Input(UInt(17.W)) }) val x = Wire(new ExampleBundle(31, 17)) x := DontCare val m = Module(new ExampleBundleModule(x)) m.io.b.foo := io.in m.io.b.bar := io.in io.out := m.io.out } Generally cloneType can be automatically defined if all arguments to the Bundle are vals e.g. class MyCloneTypeBundle(val bitwidth: Int) extends Bundle { val field = UInt(bitwidth.W) // ... } The only caveat is if you are passing something of type Data as a “generator” parameter, in which case you should make it a private val. For example, consider the following Bundle. Because its gen variable is not a private val, the user has to explicitly define the cloneType method. import chisel3.util.{Decoupled, Irrevocable} class RegisterWriteIOExplicitCloneType[T &lt;: Data](gen: T) extends Bundle { val request = Flipped(Decoupled(gen)) val response = Irrevocable(Bool()) override def cloneType = new RegisterWriteIOExplicitCloneType(gen).asInstanceOf[this.type] } We can make this this infer cloneType by making gen private since it is a “type parameter”: class RegisterWriteIO[T &lt;: Data](private val gen: T) extends Bundle { val request = Flipped(Decoupled(gen)) val response = Irrevocable(Bool()) }"
    } ,    
    {
      "title": "Enumerations",
      "url": "/chisel3/docs/explanations/chisel-enum.html",
      "content": "ChiselEnum The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations. In contrast withChisel.util.Enum, ChiselEnum are subclasses of Data, which means that they can be used to define fields in Bundles, including in IOs. Functionality and Examples // Imports used in the following examples import chisel3._ import chisel3.util._ import chisel3.stage.ChiselStage import chisel3.experimental.ChiselEnum Below we see ChiselEnum being used as mux select for a RISC-V core. While wrapping the object in a package is not required, it is highly recommended as it allows for the type to be used in multiple files more easily. // package CPUTypes { object AluMux1Sel extends ChiselEnum { val selectRS1, selectPC = Value /** How the values will be mapped \"selectRS1\" -&gt; 0.U, \"selectPC\" -&gt; 1.U */ } Here we see a mux using the AluMux1Sel to select between different inputs. import AluMux1Sel._ class AluMux1Bundle extends Bundle { val aluMux1Sel = Input( AluMux1Sel() ) val rs1Out = Input(Bits(32.W)) val pcOut = Input(Bits(32.W)) val aluMux1Out = Output(Bits(32.W)) } class AluMux1File extends Module { val io = IO(new AluMux1Bundle) // Default value for aluMux1Out io.aluMux1Out := 0.U switch (io.aluMux1Sel) { is (selectRS1) { io.aluMux1Out := io.rs1Out } is (selectPC) { io.aluMux1Out := io.pcOut } } } module AluMux1File( input clock, input reset, input io_aluMux1Sel, input [31:0] io_rs1Out, input [31:0] io_pcOut, output [31:0] io_aluMux1Out ); wire _T_2 = ~io_aluMux1Sel; // @[Conditional.scala 37:30] wire [31:0] _GEN_0 = io_aluMux1Sel ? io_pcOut : 32'h0; // @[Conditional.scala 39:67 chisel-enum.md 57:28 chisel-enum.md 50:19] assign io_aluMux1Out = _T_2 ? io_rs1Out : _GEN_0; // @[Conditional.scala 40:58 chisel-enum.md 54:28] endmodule ChiselEnum also allows for the user to define variables by passing in the value shown below. Note that the value must be increasing or else chisel3.internal.ChiselException: Exception thrown when elaborating ChiselGeneratorAnnotation is thrown during Verilog generation. object Opcode extends ChiselEnum { val load = Value(0x03.U) // i \"load\" -&gt; 000_0011 val imm = Value(0x13.U) // i \"imm\" -&gt; 001_0011 val auipc = Value(0x17.U) // u \"auipc\" -&gt; 001_0111 val store = Value(0x23.U) // s \"store\" -&gt; 010_0011 val reg = Value(0x33.U) // r \"reg\" -&gt; 011_0011 val lui = Value(0x37.U) // u \"lui\" -&gt; 011_0111 val br = Value(0x63.U) // b \"br\" -&gt; 110_0011 val jalr = Value(0x67.U) // i \"jalr\" -&gt; 110_0111 val jal = Value(0x6F.U) // j \"jal\" -&gt; 110_1111 } The user can ‘jump’ to a value and continue incrementing by passing a start point then using a regular Value assignment. object BranchFunct3 extends ChiselEnum { val beq, bne = Value val blt = Value(4.U) val bge, bltu, bgeu = Value /** How the values will be mapped \"beq\" -&gt; 0.U, \"bne\" -&gt; 1.U, \"blt\" -&gt; 4.U, \"bge\" -&gt; 5.U, \"bltu\" -&gt; 6.U, \"bgeu\" -&gt; 7.U */ } Testing When testing your modules, the .Type and .litValue attributes allow for the the objects to be passed as parameters and for the value to be converted to BigInt type. Note that BigInts cannot be casted to Int with .asInstanceOf[Int], they use their own methods like toInt. Please review the scala.math.BigInt page for more details! def expectedSel(sel: AluMux1Sel.Type): Boolean = sel match { case AluMux1Sel.selectRS1 =&gt; (sel.litValue == 0) case AluMux1Sel.selectPC =&gt; (sel.litValue == 1) case _ =&gt; false } The ChiselEnum type also has methods .all and .getWidth where all returns all of the enum instances and getWidth returns the width of the hardware type. Workarounds As of 2/26/2021, the width of the values is always inferred. To work around this, you can add an extra Value that forces the width that is desired. This is shown in the example below, where we add a field ukn to force the width to be 3 bits wide: object StoreFunct3 extends ChiselEnum { val sb, sh, sw = Value val ukn = Value(7.U) /** How the values will be mapped \"sb\" -&gt; 0.U, \"sh\" -&gt; 1.U, \"sw\" -&gt; 2.U */ } Signed values are not supported so if you want the value signed, you must cast the UInt with .asSInt. Additional Resources The ChiselEnum type is much more powerful than stated above. It allows for Sequence, Vec, and Bundle assignments, as well as a .next operation to allow for stepping through sequential states and an .isValid for checking that a hardware value is a valid Value. The source code for the ChiselEnum can be found here in the class EnumFactory. Examples of the ChiselEnum operations can be found here."
    } ,    
    {
      "title": "Chisel3 vs. Chisel2",
      "url": "/chisel3/docs/appendix/chisel3-vs-chisel2.html",
      "content": "Chisel3 vs Chisel2 Chisel2 Migration For those moving from Chisel2, there were some backwards incompatible changes and your RTL needs to be modified to work with Chisel3. The required modifications are: Wire declaration style: val wire = UInt(width = 15) becomes (in Chisel3): val wire = Wire(UInt(15.W)) I/O declaration style: val done = Bool(OUTPUT) becomes (in Chisel3): val wire = Output(Bool()) Sequential memories: val addr = Reg(UInt()) val mem = Mem(UInt(8.W), 1024, seqRead = true) val dout = when(enable) { mem(addr) } becomes (in Chisel3): val addr = UInt() val mem = SyncReadMem(1024, UInt(8.W)) val dout = mem.read(addr, enable) Notice the address register is now internal to the SyncReadMem(), but the data will still return on the subsequent cycle. Generating Verilog for a module: object Hello { def main(args: Array[String]): Unit = { chiselMain(Array(\"--backend\", \"v\"), () =&gt; Module(new Hello())) } } becomes (in Chisel3): import chisel3.stage.ChiselStage object Hello { def main(args: Array[String]): Unit = { (new ChiselStage).emitVerilog(new Hello()) } } Package changes: Chisel.log2Ceil -&gt; chisel3.util.log2Ceil BitPat Decoupled is also in chisel3.util Please refer to the Chisel3 compatibility section for instructions on preparing your Chisel2 designs for Chisel3. Deprecated Usage Vec(Reg) should be replaced with Reg(Vec), type-only vals (no associated data) must be wrapped in a Wire() if they will be the destination of a wiring operation (“:=” or “ &lt; &gt;”), masked bit patterns (‘b??’) should be created using BitPat(), not UInt() or Bits(), the clone method required for parameterized Bundles has been renamed cloneType, the con and alt inputs to a Mux must be type-compatible - both signed or both unsigned, bulk-connection to a node that has been procedurally assigned-to is illegal, != is deprecated, use =/= instead, use SyncReadMem(...) instead of Mem(..., seqRead), use SyncReadMem(n:Int, out: =&gt; T) instead of SyncReadMem(out: =&gt; T, n:Int), use SyncReadMem(...) instead of SeqMem(...), use Mem(n:Int, t:T) instead of Mem(out:T, n:Int), use Vec(n:Int, gen: =&gt; T) instead of Vec(gen: =&gt; T, n:Int), module io’s must be wrapped in IO(). The methods asInput, asOutput, and flip should be replaced by the Input(), Output(), and Flipped() object apply methods. Unsupported constructs Mem(..., orderedWrites) is no longer supported, masked writes are only supported for Mem[Vec[_]], Chisel3 Vecs must all have the same type, unlike with Chisel2. Use MixedVec (see Bundles and Vecs) for Vecs where the elements are of different types. connections between UInt and SInt are illegal. the Node class and object no longer exist (the class should have been private in Chisel2) printf() is defined in the Chisel object and produces simulation printf()’s. To use the Scala Predef.printf(), you need to qualify it with Predef. in Chisel2, bulk-connects &lt;&gt; with unconnected source components do not update connections from the unconnected components. ** In Chisel3, bulk-connects strictly adhere to last connection semantics and unconnected OUTPUTs will be connected to INPUTs resulting in the assignment of random values to those inputs. In Chisel3, adding hardware inside BlackBox for simulation is no longer supported. (#289) ChiselError is gone Change ChiselError.error(\"error msg\") to throw new Error(\"error msg\") Change ChiselError.info(\"info msg\") to println(\"info msg\") In Chisel3, subword assignments are not supported. Alternative constructions exist in Chisel3. Further changes The clock signal was renamed from clk to clock in Chisel3. Change getWidth() to getWidth Packaging Chisel3 is implemented as several packages. The core DSL is differentiated from utility or library classes and objects, testers, and interpreters. The prime components of the Chisel3 front end (the DSL and library objects) are: coreMacros - source locators provide Chisel line numbers for firrtl detected errors, chiselFrontend - main DSL components, chisel3 - compiler driver, interface packages, compatibility layer. Due to the wonders of sbt, you need only declare a dependency on the chisel3 package, and the others will be downloaded as required. The firrtl compiler is distributed as a separate package, and release versions will also be downloaded automatically as required. If you choose to integrate the compiler into your own toolchain, or you’re working with the development (master) branch of chisel3, you should clone the firrtl repo and follow the instructions for installing the firrtl compiler. The testers in Chisel3 are distributed as a separate package. If you intend to use them in your tests, you will either need to clone the chisel-testers repo or declare a dependency on the published version of the package. See the build.sbt file in either the chisel-template or chisel-tutorial repos for examples of the latter. Simulation Chisel2 was capable of directly generating a C++ simulation from the Chisel code, or a harness for use with a vcs simulation. Chisel3 relies on verilator to generate the C++ simulation from the Verilog output of firrtl. See the Chisel3 README for directions on installing verilator. Compile Options and Front End Checks (Strict vs. NotStrict) Chisel3 introduces a formal specification for hardware circuit graphs: FIRRTL, and Chisel3 itself (the Scala library implementing the Chisel DSL), is a relatively thin front end that generates FIRRTL. Since the firrtl parser needs to validate FIRRTL input, most of the checks that were performed in Chisel2 were eliminated from the initial Chisel3 front end (the DRY principle). However, this does impact the ability to provide detailed messages for error conditions that could be detected in the Chisel3 front end. The decision was made to optionally enable stricter error checking (for connections and the use of raw types versus hardware objects), based on specific imports. This allows designs to move from less strict front end checks (largely compatible with Chisel2), to stricter checking, on a file by file basis, by adjusting specific import statements. import chisel3.ExplicitCompileOptions.Strict enables stricter connection and usage checks, while import chisel3.ExplicitCompileOptions.NotStrict defers these checks to the firrtl compiler. By default, the Chisel compatibility layer, invoked by: import Chisel._ implicitly defines the compile options as chisel3.core.ExplicitCompileOptions.NotStrict whereas the Chisel3 package, invoked by: import chisel3._ implicitly defines the compile options as chisel3.core.ExplicitCompileOptions.Strict Again, these implicit compile options definitions may be overridden by explicit imports. Currently, the specific error checks (found in CompileOptions.scala) are: trait CompileOptions { // Should Bundle connections require a strict match of fields. // If true and the same fields aren't present in both source and sink, a MissingFieldException, // MissingLeftFieldException, or MissingRightFieldException will be thrown. val connectFieldsMustMatch: Boolean // When creating an object that takes a type argument, the argument must be unbound (a pure type). val declaredTypeMustBeUnbound: Boolean // Module IOs should be wrapped in an IO() to define their bindings before the reset of the module is defined. val requireIOWrap: Boolean // If a connection operator fails, don't try the connection with the operands (source and sink) reversed. val dontTryConnectionsSwapped: Boolean // If connection directionality is not explicit, do not use heuristics to attempt to determine it. val dontAssumeDirectionality: Boolean // Issue a deprecation warning if Data.{flip, asInput,asOutput} is used // instead of Flipped, Input, or Output. val deprecateOldDirectionMethods: Boolean // Check that referenced Data have actually been declared. val checkSynthesizable: Boolean } chisel3.core.ExplicitCompileOptions.Strict sets all CompileOptions fields to true and chisel3.core.ExplicitCompileOptions.NotStrict sets them all to false. Clients are free to define their own settings for these options. Examples may be found in the test CompileOptionsSpec"
    } ,    
    {
      "title": "Combinational Circuits",
      "url": "/chisel3/docs/explanations/combinational-circuits.html",
      "content": "Combinational Circuits A circuit is represented as a graph of nodes in Chisel. Each node is a hardware operator that has zero or more inputs and that drives one output. A literal, introduced above, is a degenerate kind of node that has no inputs and drives a constant value on its output. One way to create and wire together nodes is using textual expressions. For example, we can express a simple combinational logic circuit using the following expression: (a &amp; b) | (~c &amp; d) The syntax should look familiar, with &amp; and | representing bitwise-AND and -OR respectively, and ~ representing bitwise-NOT. The names a through d represent named wires of some (unspecified) width. Any simple expression can be converted directly into a circuit tree, with named wires at the leaves and operators forming the internal nodes. The final circuit output of the expression is taken from the operator at the root of the tree, in this example, the bitwise-OR. Simple expressions can build circuits in the shape of trees, but to construct circuits in the shape of arbitrary directed acyclic graphs (DAGs), we need to describe fan-out. In Chisel, we do this by naming a wire that holds a subexpression that we can then reference multiple times in subsequent expressions. We name a wire in Chisel by declaring a variable. For example, consider the select expression, which is used twice in the following multiplexer description: val sel = a | b val out = (sel &amp; in1) | (~sel &amp; in0) The keyword val is part of Scala, and is used to name variables that have values that won’t change. It is used here to name the Chisel wire, sel, holding the output of the first bitwise-OR operator so that the output can be used multiple times in the second expression. Wires Chisel also supports wires as hardware nodes to which one can assign values or connect other nodes. val myNode = Wire(UInt(8.W)) when (isReady) { myNode := 255.U } .otherwise { myNode := 0.U } val myNode = Wire(UInt(8.W)) when (input &gt; 128.U) { myNode := 255.U } .elsewhen (input &gt; 64.U) { myNode := 1.U } .otherwise { myNode := 0.U } Note that the last connection to a Wire takes effect. For example, the following two Chisel circuits are equivalent: val myNode = Wire(UInt(8.W)) myNode := 10.U myNode := 0.U val myNode = Wire(UInt(8.W)) myNode := 0.U"
    } ,    
    {
      "title": "Community",
      "url": "/community.html",
      "content": "Chisel Users Community If you’re a Chisel user and want to stay connected to the wider user community, any of the following are great avenues: Interact with other Chisel users in one of our Gitter chat rooms: Chisel FIRRTL Ask/Answer Questions on Stack Overflow using the [chisel] tag Ask questions and discuss ideas on the Chisel/FIRRTL Mailing Lists: Chisel Users Chisel Developers Follow us on our @chisel_lang Twitter Account Subscribe to our chisel-lang YouTube Channel Projects Using Chisel/FIRRTL If you want to add your project to the list, let us know on the Chisel users mailing list! Chisel Project Description Author Links Rocket Chip Generator RISC-V System-on-Chip Generator, 5-stage RISC-V Microprocessor @ucb-bar, @sifive Report Berkeley Out-of-order Machine RISC-V Out-of-order/Multi-issue Microprocessor @ucb-bar Site, Thesis RISC-V Mini 3-stage RISC-V Microprocessor @ucb-bar   Sodor Processor Collection Educational RISC-V Microprocessors (1, 2, 3, 5-stage) @ucb-bar   Patmos Time-predictable VLIW processor @t-crest Site OpenSoC Fabric Parametrizable Network-on-Chip Generator @LBL-CoDEx Site Hwacha Decoupled Vector-fetch Accelerator @ucb-bar Report DANA Multilayer Perceptron Accelerator for Rocket @bu-icsg Paper Gemmini Systolic-array Accelerator Generator @ucb-bar Paper Edge TPU AI Inference Accelerator @google Video ChiselFlow Information Flow Types in Chisel3 @apl-cornell Paper PHMon Programmable Hardware Monitor @bu-icsg Paper DINO CPU Davis In-Order (DINO) CPU models @jlpteaching Paper Quasar CHISEL implementation of SweRV-EL2 @Lampro-Mellon Video FIRRTL Project Description Author Links MIDAS/DESSERT/Golden Gate FPGA Accelerated Simulation @ucb-bar Papers 1, 2, 3, Video Chiffre Run-time Fault Injection @IBM Paper SIRRTL Security-typed FIRRTL @apl-cornell Paper obfuscation Transforms to Obfuscate FIRRTL Circuits @jpsety   Area/Timing Estimates Transforms for Area and Timing Estimates @intel Video Chisel Developers Community If you want to get more involved with the Chisel/FIRRTL ecosystem of projects, feel free to reach out to us on any of the mediums above. If you prefer to dive right in (or have bugs to report), a complete list of the associated Chisel/FIRRTL ecosystem of projects is below: Chisel FIRRTL Chisel Testers/chisel3.iotesters Chisel Testers2/chisel3.testers Treadle Diagrammer Contributors Chisel, FIRRTL, and all related projects would not be possible without the contributions of our fantastic developer community. The following people have contributed to the current release of the projects: {% include_relative contributors.md %} Papers While Chisel has come a long way since 2012, the original Chisel paper provides some background on motivations and an overview of the (now deprecated) Chisel 2 language: Bachrach, Jonathan, et al. “Chisel: constructing hardware in a scala embedded language.” DAC Design Automation Conference 2012. IEEE, 2012. The FIRRTL IR and FIRRTL compiler, introduced as part of Chisel 3, are discussed in both the following paper and specification1: Izraelevitz, Adam, et al. “Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations.” Proceedings of the 36th International Conference on Computer-Aided Design. IEEE Press, 2017. Li, Patrick S., Adam M. Izraelevitz, and Jonathan Bachrach. “Specification for the FIRRTL Language.” EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2016-9 (2016). Finally, Chisel’s functional programming and bit-width inference ideas were inspired by earlier work on a hardware description language called Gel: Bachrach, Jonathan, Dany Qumsiyeh, and Mark Tobenkin. “Hardware scripting in gel.” 2008 16th International Symposium on Field-Programmable Custom Computing Machines. IEEE, 2008. Attribution If you use Chisel in your research, consider citing: @inproceedings{bachrach:2012:chisel, author={J. {Bachrach} and H. {Vo} and B. {Richards} and Y. {Lee} and A. {Waterman} and R {Avižienis} and J. {Wawrzynek} and K. {Asanović}}, booktitle={DAC Design Automation Conference 2012}, title={Chisel: Constructing hardware in a Scala embedded language}, year={2012}, volume={}, number={}, pages={1212-1221}, keywords={application specific integrated circuits;C++ language;field programmable gate arrays;hardware description languages;Chisel;Scala embedded language;hardware construction language;hardware design abstraction;functional programming;type inference;high-speed C++-based cycle-accurate software simulator;low-level Verilog;FPGA;standard ASIC flow;Hardware;Hardware design languages;Generators;Registers;Wires;Vectors;Finite impulse response filter;CAD}, doi={10.1145/2228360.2228584}, ISSN={0738-100X}, month={June},} If you use FIRRTL in your research consider citing: @INPROCEEDINGS{8203780, author={A. Izraelevitz and J. Koenig and P. Li and R. Lin and A. Wang and A. Magyar and D. Kim and C. Schmidt and C. Markley and J. Lawson and J. Bachrach}, booktitle={2017 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)}, title={Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations}, year={2017}, volume={}, number={}, pages={209-216}, keywords={field programmable gate arrays;hardware description languages;program compilers;software reusability;hardware development practices;hardware libraries;open-source hardware intermediate representation;hardware compiler transformations;Hardware construction languages;retargetable compilers;software development;virtual Cambrian explosion;hardware compiler frameworks;parameterized libraries;FIRRTL;FPGA mappings;Chisel;Flexible Intermediate Representation for RTL;Reusability;Hardware;Libraries;Hardware design languages;Field programmable gate arrays;Tools;Open source software;RTL;Design;FPGA;ASIC;Hardware;Modeling;Reusability;Hardware Design Language;Hardware Construction Language;Intermediate Representation;Compiler;Transformations;Chisel;FIRRTL}, doi={10.1109/ICCAD.2017.8203780}, ISSN={1558-2434}, month={Nov},} @techreport{Li:EECS-2016-9, Author = {Li, Patrick S. and Izraelevitz, Adam M. and Bachrach, Jonathan}, Title = {Specification for the FIRRTL Language}, Institution = {EECS Department, University of California, Berkeley}, Year = {2016}, Month = {Feb}, URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-9.html}, Number = {UCB/EECS-2016-9} } This specification is provided for historical perspective. For the latest version of the FIRRTL specification you can use this link. &#8617;"
    } ,    
    {
      "title": "General Cookbook",
      "url": "/chisel3/docs/cookbooks/cookbook.html",
      "content": "General Cookbook Please note that these examples make use of Chisel’s scala-style printing. Converting Chisel Types to/from UInt How do I create a UInt from an instance of a Bundle? How do I create a Bundle from a UInt? How can I tieoff a Bundle/Vec to 0? How do I create a Vec of Bools from a UInt? How do I create a UInt from a Vec of Bool? Vectors and Registers How do I create a Vector of Registers? How do I create a Reg of type Vec? How do I create a finite state machine? How do I unpack a value (“reverse concatenation”) like in Verilog? How do I do subword assignment (assign to some bits in a UInt)? How do I create an optional I/O? Predictable Naming How do I get Chisel to name signals properly in blocks like when/withClockAndReset? How do I get Chisel to name the results of vector reads properly? How can I dynamically set/parametrize the name of a module? Converting Chisel Types to/from UInt How do I create a UInt from an instance of a Bundle? Call asUInt on the Bundle instance. import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = UInt(4.W) } class Foo extends RawModule { val bundle = Wire(new MyBundle) bundle.foo := 0xc.U bundle.bar := 0x3.U val uint = bundle.asUInt } How do I create a Bundle from a UInt? Use the asTypeOf method to reinterpret the UInt as the type of the Bundle. import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = UInt(4.W) } class Foo extends RawModule { val uint = 0xb4.U val bundle = uint.asTypeOf(new MyBundle) } How can I tieoff a Bundle/Vec to 0? You can use asTypeOf as above. If you don’t want to worry about the type of the thing you are tying off, you can use chiselTypeOf: import chisel3._ class MyBundle extends Bundle { val foo = UInt(4.W) val bar = Vec(4, UInt(1.W)) } class Foo(typ: Data) extends RawModule { val bundleA = IO(Output(typ)) val bundleB = IO(Output(typ)) // typ is already a Chisel Data Type, so can use it directly here, but you // need to know that bundleA is of type typ bundleA := 0.U.asTypeOf(typ) // bundleB is a Hardware data IO(Output(...)) so need to call chiselTypeOf, // but this will work no matter the type of bundleB: bundleB := 0.U.asTypeOf(chiselTypeOf(bundleB)) } class Bar extends RawModule { val foo = Module(new Foo(new MyBundle())) } How do I create a Vec of Bools from a UInt? Use VecInit given a Seq[Bool] generated using the asBools method. import chisel3._ class Foo extends RawModule { val uint = 0xc.U val vec = VecInit(uint.asBools) } How do I create a UInt from a Vec of Bool? Use the builtin function asUInt import chisel3._ class Foo extends RawModule { val vec = VecInit(true.B, false.B, true.B, true.B) val uint = vec.asUInt } Vectors and Registers How do I create a Vector of Registers? Rule! Use Reg of Vec not Vec of Reg! You create a Reg of type Vec. Because Vecs are a type (like UInt, Bool) rather than a value, we must bind the Vec to some concrete value. How do I create a Reg of type Vec? For more information, the API Documentation for Vec provides more information. import chisel3._ class Foo extends RawModule { val regOfVec = Reg(Vec(4, UInt(32.W))) // Register of 32-bit UInts regOfVec(0) := 123.U // Assignments to elements of the Vec regOfVec(1) := 456.U regOfVec(2) := 789.U regOfVec(3) := regOfVec(0) // Reg of Vec of 32-bit UInts initialized to zero // Note that Seq.fill constructs 4 32-bit UInt literals with the value 0 // VecInit(...) then constructs a Wire of these literals // The Reg is then initialized to the value of the Wire (which gives it the same type) val initRegOfVec = RegInit(VecInit(Seq.fill(4)(0.U(32.W)))) } How do I create a finite state machine (FSM)? The advised way is to use ChiselEnum to construct enumerated types representing the state of the FSM. State transitions are then handled with switch/is and when/.elsewhen/.otherwise. import chisel3._ import chisel3.util.{switch, is} import chisel3.experimental.ChiselEnum object DetectTwoOnes { object State extends ChiselEnum { val sNone, sOne1, sTwo1s = Value } } /* This FSM detects two 1's one after the other */ class DetectTwoOnes extends Module { import DetectTwoOnes.State import DetectTwoOnes.State._ val io = IO(new Bundle { val in = Input(Bool()) val out = Output(Bool()) val state = Output(State()) }) val state = RegInit(sNone) io.out := (state === sTwo1s) io.state := state switch (state) { is (sNone) { when (io.in) { state := sOne1 } } is (sOne1) { when (io.in) { state := sTwo1s } .otherwise { state := sNone } } is (sTwo1s) { when (!io.in) { state := sNone } } } } Note: the is statement can take multiple conditions e.g. is (sTwo1s, sOne1) { ... }. How do I unpack a value (“reverse concatenation”) like in Verilog? In Verilog, you can do something like the following which will unpack a the value z: wire [1:0] a; wire [3:0] b; wire [2:0] c; wire [8:0] z = [...]; assign {a,b,c} = z; Unpacking often corresponds to reinterpreting an unstructured data type as a structured data type. Frequently, this structured type is used prolifically in the design, and has been declared as in the following example: import chisel3._ class MyBundle extends Bundle { val a = UInt(2.W) val b = UInt(4.W) val c = UInt(3.W) } The easiest way to accomplish this in Chisel would be: class Foo extends RawModule { val z = Wire(UInt(9.W)) z := DontCare // This is a dummy connection val unpacked = z.asTypeOf(new MyBundle) printf(\"%d\", unpacked.a) printf(\"%d\", unpacked.b) printf(\"%d\", unpacked.c) } If you really need to do this for a one-off case (Think thrice! It is likely you can better structure the code using bundles), then rocket-chip has a Split utility which can accomplish this. How do I do subword assignment (assign to some bits in a UInt)? You may try to do something like the following where you want to assign only some bits of a Chisel type. Below, the left-hand side connection to io.out(0) is not allowed. import chisel3._ import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation} class Foo extends Module { val io = IO(new Bundle { val bit = Input(Bool()) val out = Output(UInt(10.W)) }) io.out(0) := io.bit } If you try to compile this, you will get an error. (new ChiselStage).execute(Array(\"-X\", \"verilog\"), Seq(new ChiselGeneratorAnnotation(() =&gt; new Foo))) // chisel3.internal.ChiselException: Cannot reassign to read-only Bool(OpResult in Foo) // at ... () // at repl.MdocSession$App8$Foo.&lt;init&gt;(cookbook.md:242) // at repl.MdocSession$App8$$anonfun$51$$anonfun$apply$27.apply(cookbook.md:250) // at repl.MdocSession$App8$$anonfun$51$$anonfun$apply$27.apply(cookbook.md:250) // at ... () // at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace) Chisel3 does not support subword assignment. The reason for this is that subword assignment generally hints at a better abstraction with an aggregate/structured types, i.e., a Bundle or a Vec. If you must express it this way, one approach is to blast your UInt to a Vec of Bool and back: import chisel3._ class Foo extends Module { val io = IO(new Bundle { val in = Input(UInt(10.W)) val bit = Input(Bool()) val out = Output(UInt(10.W)) }) val bools = VecInit(io.in.asBools) bools(0) := io.bit io.out := bools.asUInt } How do I create an optional I/O? The following example is a module which includes the optional port out2 only if the given parameter is true. import chisel3._ class ModuleWithOptionalIOs(flag: Boolean) extends Module { val io = IO(new Bundle { val in = Input(UInt(12.W)) val out = Output(UInt(12.W)) val out2 = if (flag) Some(Output(UInt(12.W))) else None }) io.out := io.in if (flag) { io.out2.get := io.in } } The following is an example for a MultiIOModule where an entire IO is optional: import chisel3._ class ModuleWithOptionalIO(flag: Boolean) extends MultiIOModule { val in = if (flag) Some(IO(Input(Bool()))) else None val out = IO(Output(Bool())) out := in.getOrElse(false.B) } Predictable Naming How do I get Chisel to name signals properly in blocks like when/withClockAndReset? To get Chisel to name signals (wires and registers) declared inside of blocks like when, withClockAndReset, etc, use the @chiselName annotation as shown below: import chisel3._ import chisel3.experimental.chiselName @chiselName class TestMod extends Module { val io = IO(new Bundle { val a = Input(Bool()) val b = Output(UInt(4.W)) }) when (io.a) { val innerReg = RegInit(5.U(4.W)) innerReg := innerReg + 1.U io.b := innerReg } .otherwise { io.b := 10.U } } Note that you will need to add the following line to your project’s build.sbt file. addCompilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.1.0\" cross CrossVersion.full) If we compile this module without @chiselName, Chisel is not able to name innerReg correctly (notice the _T): Elaborating design… [\u001b[34mdeprecated\u001b[0m] class repl.MdocSession$App12$TestModWithout\\(anonfun$76\\)anonfun$apply$36\\(anon$6 (1 calls): chisel3.1 autoclonetype failed, falling back to 3.0 behavior using null as the outer instance. Autoclonetype failure reason: Unable to determine instance of outer class class repl.MdocSession$App12$TestModWithout\\)anonfun$76$$anonfun$apply$36, no candidates assignable to outer class types; examined List(repl.MdocSession$App12$TestModWithout@70f528f8) [\u001b[33mwarn\u001b[0m] \u001b[33mThere were 1 deprecated function(s) used. These may stop compiling in a future release - you are encouraged to fix these issues.\u001b[0m [\u001b[33mwarn\u001b[0m] Line numbers for deprecations reported by Chisel may be inaccurate; enable scalac compiler deprecation warnings via either of the following methods: [\u001b[33mwarn\u001b[0m] In the sbt interactive console, enter: [\u001b[33mwarn\u001b[0m] set scalacOptions in ThisBuild ++= Seq(“-unchecked”, “-deprecation”) [\u001b[33mwarn\u001b[0m] or, in your build.sbt, add the line: [\u001b[33mwarn\u001b[0m] scalacOptions := Seq(“-unchecked”, “-deprecation”) Done elaborating. However, if we use @chiselName then the register previously called _T is now innerReg: Elaborating design… [\u001b[34mdeprecated\u001b[0m] class repl.MdocSession$App12$TestMod\\(anonfun$69\\)anonfun$apply$34\\(anon$5 (1 calls): chisel3.1 autoclonetype failed, falling back to 3.0 behavior using null as the outer instance. Autoclonetype failure reason: Unable to determine instance of outer class class repl.MdocSession$App12$TestMod\\)anonfun$69$$anonfun$apply$34, no candidates assignable to outer class types; examined List(repl.MdocSession$App12$TestMod@4c00c928) [\u001b[33mwarn\u001b[0m] \u001b[33mThere were 1 deprecated function(s) used. These may stop compiling in a future release - you are encouraged to fix these issues.\u001b[0m [\u001b[33mwarn\u001b[0m] Line numbers for deprecations reported by Chisel may be inaccurate; enable scalac compiler deprecation warnings via either of the following methods: [\u001b[33mwarn\u001b[0m] In the sbt interactive console, enter: [\u001b[33mwarn\u001b[0m] set scalacOptions in ThisBuild ++= Seq(“-unchecked”, “-deprecation”) [\u001b[33mwarn\u001b[0m] or, in your build.sbt, add the line: [\u001b[33mwarn\u001b[0m] scalacOptions := Seq(“-unchecked”, “-deprecation”) Done elaborating. How do I get Chisel to name the results of vector reads properly? Currently, name information is lost when using dynamic indexing. For example: class Foo extends Module { val io = IO(new Bundle { val in = Input(Vec(4, Bool())) val idx = Input(UInt(2.W)) val en = Input(Bool()) val out = Output(Bool()) }) val x = io.in(io.idx) val y = x &amp;&amp; io.en io.out := y } The above code loses the x name, instead using _GEN_3 (the other _GEN_* signals are expected). module Foo( input clock, input reset, input io_in_0, input io_in_1, input io_in_2, input io_in_3, input [1:0] io_idx, input io_en, output io_out ); wire _GEN_1; // @[main.scala 15:13] wire _GEN_2; // @[main.scala 15:13] wire _GEN_3; // @[main.scala 15:13] assign _GEN_1 = 2'h1 == io_idx ? io_in_1 : io_in_0; // @[main.scala 15:13] assign _GEN_2 = 2'h2 == io_idx ? io_in_2 : _GEN_1; // @[main.scala 15:13] assign _GEN_3 = 2'h3 == io_idx ? io_in_3 : _GEN_2; // @[main.scala 15:13] assign io_out = _GEN_3 &amp; io_en; // @[main.scala 16:10] endmodule This can be worked around by creating a wire and connecting the dynamic index to the wire: val x = WireInit(io.in(io.idx)) Which produces: module Foo( input clock, input reset, input io_in_0, input io_in_1, input io_in_2, input io_in_3, input [1:0] io_idx, input io_en, output io_out ); wire _GEN_1; wire _GEN_2; wire x; assign _GEN_1 = 2'h1 == io_idx ? io_in_1 : io_in_0; assign _GEN_2 = 2'h2 == io_idx ? io_in_2 : _GEN_1; assign x = 2'h3 == io_idx ? io_in_3 : _GEN_2; assign io_out = x &amp; io_en; // @[main.scala 16:10] endmodule How can I dynamically set/parametrize the name of a module? You can override the desiredName function. This works with normal Chisel modules and BlackBoxes. Example: import chisel3._ class Coffee extends BlackBox { val io = IO(new Bundle { val I = Input(UInt(32.W)) val O = Output(UInt(32.W)) }) override def desiredName = \"Tea\" } class Salt extends Module { val io = IO(new Bundle {}) val drink = Module(new Coffee) override def desiredName = \"SodiumMonochloride\" } Elaborating the Chisel module Salt yields our “desire name” for Salt and Coffee in the output Verilog: Elaborating design… [\u001b[34mdeprecated\u001b[0m] class repl.MdocSession$App15$Salt\\(anonfun$102\\)anonfun$apply$42\\(anon$9 (1 calls): chisel3.1 autoclonetype failed, falling back to 3.0 behavior using null as the outer instance. Autoclonetype failure reason: Unable to determine instance of outer class class repl.MdocSession$App15$Salt\\)anonfun$102\\(anonfun$apply$42, no candidates assignable to outer class types; examined List(repl.MdocSession$App15$Salt@5e2c003e) [\u001b[34mdeprecated\u001b[0m] class repl.MdocSession$App15$Coffee\\)anonfun$99\\(anonfun$apply$41\\)anon$8 (1 calls): chisel3.1 autoclonetype failed, falling back to 3.0 behavior using null as the outer instance. Autoclonetype failure reason: Unable to determine instance of outer class class repl.MdocSession$App15$Coffee\\(anonfun$99\\)anonfun$apply$41, no candidates assignable to outer class types; examined List(repl.MdocSession$App15$Coffee@7a6c7c39) [\u001b[33mwarn\u001b[0m] \u001b[33mThere were 2 deprecated function(s) used. These may stop compiling in a future release - you are encouraged to fix these issues.\u001b[0m [\u001b[33mwarn\u001b[0m] Line numbers for deprecations reported by Chisel may be inaccurate; enable scalac compiler deprecation warnings via either of the following methods: [\u001b[33mwarn\u001b[0m] In the sbt interactive console, enter: [\u001b[33mwarn\u001b[0m] set scalacOptions in ThisBuild ++= Seq(“-unchecked”, “-deprecation”) [\u001b[33mwarn\u001b[0m] or, in your build.sbt, add the line: [\u001b[33mwarn\u001b[0m] scalacOptions := Seq(“-unchecked”, “-deprecation”) Done elaborating."
    } ,    
    {
      "title": "Cookbooks",
      "url": "/chisel3/docs/cookbooks/cookbooks.html",
      "content": "Cookbooks Welcome to the Chisel Cookbooks, where we capture frequently-used design patterns or troubleshooting questions. If you have any requests or examples to share, please file an issue and let us know! General Cookbooks Naming Cookbook Troubleshooting Guide"
    } ,    
    {
      "title": "Data Types",
      "url": "/chisel3/docs/explanations/data-types.html",
      "content": "Chisel Data Types Chisel datatypes are used to specify the type of values held in state elements or flowing on wires. While hardware designs ultimately operate on vectors of binary digits, other more abstract representations for values allow clearer specifications and help the tools generate more optimal circuits. In Chisel, a raw collection of bits is represented by the Bits type. Signed and unsigned integers are considered subsets of fixed-point numbers and are represented by types SInt and UInt respectively. Signed fixed-point numbers, including integers, are represented using two’s-complement format. Boolean values are represented as type Bool. Note that these types are distinct from Scala’s builtin types such as Int or Boolean. There is a new experimental type Interval which gives the developer more control of the type by allowing the definition of an IntervalRange. See: Interval Type Additionally, Chisel defines Bundles for making collections of values with named fields (similar to structs in other languages), and Vecs for indexable collections of values. Bundles and Vecs will be covered later. Constant or literal values are expressed using Scala integers or strings passed to constructors for the types: 1.U // decimal 1-bit lit from Scala Int. \"ha\".U // hexadecimal 4-bit lit from string. \"o12\".U // octal 4-bit lit from string. \"b1010\".U // binary 4-bit lit from string. 5.S // signed decimal 4-bit lit from Scala Int. -8.S // negative decimal 4-bit lit from Scala Int. 5.U // unsigned decimal 3-bit lit from Scala Int. 8.U(4.W) // 4-bit unsigned decimal, value 8. -152.S(32.W) // 32-bit signed decimal, value -152. true.B // Bool lits from Scala lits. false.B Underscores can be used as separators in long string literals to aid readability, but are ignored when creating the value, e.g.: \"h_dead_beef\".U // 32-bit lit of type UInt By default, the Chisel compiler will size each constant to the minimum number of bits required to hold the constant, including a sign bit for signed types. Bit widths can also be specified explicitly on literals, as shown below. Note that (.W is used to cast a Scala Int to a Chisel width) \"ha\".asUInt(8.W) // hexadecimal 8-bit lit of type UInt \"o12\".asUInt(6.W) // octal 6-bit lit of type UInt \"b1010\".asUInt(12.W) // binary 12-bit lit of type UInt 5.asSInt(7.W) // signed decimal 7-bit lit of type SInt 5.asUInt(8.W) // unsigned decimal 8-bit lit of type UInt For literals of type UInt, the value is zero-extended to the desired bit width. For literals of type SInt, the value is sign-extended to fill the desired bit width. If the given bit width is too small to hold the argument value, then a Chisel error is generated. We are working on a more concise literal syntax for Chisel using symbolic prefix operators, but are stymied by the limitations of Scala operator overloading and have not yet settled on a syntax that is actually more readable than constructors taking strings. We have also considered allowing Scala literals to be automatically converted to Chisel types, but this can cause type ambiguity and requires an additional import. The SInt and UInt types will also later support an optional exponent field to allow Chisel to automatically produce optimized fixed-point arithmetic circuits. Casting We can also cast types in Chisel: val sint = 3.S(4.W) // 4-bit SInt val uint = sint.asUInt // cast SInt to UInt uint.asSInt // cast UInt to SInt NOTE: asUInt/asSInt with an explicit width can not be used to cast (convert) between Chisel datatypes. No width parameter is accepted, as Chisel will automatically pad or truncate as required when the objects are connected. We can also perform casts on clocks, though you should be careful about this, since clocking (especially in ASIC) requires special attention: val bool: Bool = false.B // always-low wire val clock = bool.asClock // always-low clock clock.asUInt // convert clock to UInt (width 1) clock.asUInt.asBool // convert clock to Bool (Chisel 3.2+) clock.asUInt.toBool // convert clock to Bool (Chisel 3.0 and 3.1 only) Analog/BlackBox type (Experimental, Chisel 3.1+) Chisel supports an Analog type (equivalent to Verilog inout) that can be used to support arbitrary nets in Chisel. This includes analog wires, tri-state/bi-directional wires, and power nets (with appropriate annotations). Analog is an undirectioned type, and so it is possible to connect multiple Analog nets together using the attach operator. It is possible to connect an Analog once using &lt;&gt; but illegal to do it more than once. val a = IO(Analog(1.W)) val b = IO(Analog(1.W)) val c = IO(Analog(1.W)) // Legal attach(a, b) attach(a, c) // Legal a &lt;&gt; b // Illegal - connects 'a' multiple times a &lt;&gt; b a &lt;&gt; c"
    } ,    
    {
      "title": "Developers",
      "url": "/chisel3/docs/developers/developers.html",
      "content": "Developer Documentation Tips and tricks for Chisel developers: Embedding Chisel as an sbt subproject Test Coverage"
    } ,    
    {
      "title": "Experimental Features",
      "url": "/chisel3/docs/appendix/experimental-features.html",
      "content": "Chisel has a number of new features that are worth checking out. This page is an informal list of these features and projects. FixedPoint Module Variants Module Variants Interval Type Loading Memories for simulation or FPGA initialization FixedPoint FixedPoint numbers are basic Data type along side of UInt, SInt, etc. Most common math and logic operations are supported. Chisel allows both the width and binary point to be inferred by the Firrtl compiler which can simplify circuit descriptions. See FixedPointSpec Module Variants The standard Chisel Module requires a val io = IO(...), the experimental package introduces several new ways of defining Modules BaseModule: no contents, instantiable BlackBox extends BaseModule UserDefinedModule extends BaseModule: this module can contain Chisel RTL. No default clock or reset lines. No default IO. - User should be able to specify non-io ports, ideally multiple of them. ImplicitModule extends UserModule: has clock, reset, and io, essentially current Chisel Module. RawModule: will be the user-facing version of UserDefinedModule Module: type-aliases to ImplicitModule, the user-facing version of ImplicitModule. Bundle Literals Bundle literals can be constructed via an experimental import: import chisel3._ import chisel3.experimental.BundleLiterals._ class MyBundle extends Bundle { val a = UInt(8.W) val b = Bool() } class Example extends RawModule { val out = IO(Output(new MyBundle)) out := (new MyBundle).Lit(_.a -&gt; 8.U, _.b -&gt; true.B) } module Example( output [7:0] out_a, output out_b ); assign out_a = 8'h8; // @[experimental-features.md 22:7] assign out_b = 1'h1; // @[experimental-features.md 22:7] endmodule Partial specification is allowed, defaulting any unconnected fields to 0 (regardless of type). class Example2 extends RawModule { val out = IO(Output(new MyBundle)) out := (new MyBundle).Lit(_.b -&gt; true.B) } module Example2( output [7:0] out_a, output out_b ); assign out_a = 8'h0; assign out_b = 1'h1; // @[experimental-features.md 37:7] endmodule Bundle literals can also be nested arbitrarily. class ChildBundle extends Bundle { val foo = UInt(8.W) } class ParentBundle extends Bundle { val a = UInt(8.W) val b = new ChildBundle } class Example3 extends RawModule { val out = IO(Output(new ParentBundle)) out := (new ParentBundle).Lit(_.a -&gt; 123.U, _.b -&gt; (new ChildBundle).Lit(_.foo -&gt; 42.U)) } module Example3( output [7:0] out_a, output [7:0] out_b_foo ); assign out_a = 8'h7b; // @[experimental-features.md 63:7] assign out_b_foo = 8'h2a; // @[experimental-features.md 63:7] endmodule Vec literals are not yet supported. Interval Type Intervals are a new experimental numeric type that comprises UInt, SInt and FixedPoint numbers. It augments these types with range information, i.e. upper and lower numeric bounds. This information can be used to exercise tighter programmatic control over the ultimate widths of signals in the final circuit. The Firrtl compiler can infer this range information based on operations and earlier values in the circuit. Intervals support all the ordinary bit and arithmetic operations associated with UInt, SInt, and FixedPoint and adds the following methods for manipulating the range of a source Interval with the IntervalRange of target Interval Clip – Fit the value source into the IntervalRange of target, saturate if out of bounds The clip method applied to an interval creates a new interval based on the argument to clip, and constructs the necessary hardware so that the source Interval’s value will be mapped into the new Interval. Values that are outside the result range will be pegged to either maximum or minimum of result range as appropriate. Generates necessary hardware to clip values, values greater than range are set to range.high, values lower than range are set to range min. Wrap – Fit the value source into the IntervalRange of target, wrapping around if out of bounds The wrap method applied to an interval creates a new interval based on the argument to wrap, and constructs the necessary hardware so that the source Interval’s value will be mapped into the new Interval. Values that are outside the result range will be wrapped until they fall within the result range. Generates necessary hardware to wrap values, values greater than range are set to range.high, values lower than range are set to range min. Does not handle out of range values that are less than half the minimum or greater than twice maximum Squeeze – Fit the value source into the smallest IntervalRange based on source and target. The squeeze method applied to an interval creates a new interval based on the argument to clip, the two ranges must overlap behavior of squeeze with inputs outside of the produced range is undefined. Generates no hardware, strictly a sizing operation Range combinations Condition A.clip(B) A.wrap(B) A.squeeze(B) A === B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A contains B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) B contains A max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A min &lt; B min, A max in B max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A min in B, A max &gt; B max max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) max(Alo, Blo), min(Ahi, Bhi) A strictly less than B error error error A strictly greater than B error error error Applying binary point operators to an Interval Consider a Interval with a binary point of 3: aaa.bbb operation after operation binary point lower upper meaning setBinaryPoint(2) aaa.bb 2 X X set the precision shiftLeftBinaryPoint(2) a.aabbb 5 X X increase the precision shiftRighBinaryPoint(2) aaaa.b 1 X X reduce the precision Loading Memories for simulation or FPGA initialization Chisel supports multiple experimental methods for annotating memories to be loaded from a text file containing hex or binary data. When using verilog simulation it uses the $readmemh or $readmemb verilog extension. The treadle simulator can also load memories using the same annotation. Inline initialization with external file Memories can be initialized by generating inline readmemh or readmemb statements in the output Verilog. The function loadMemoryFromFileInline from chisel3.util.experimental allows the memory to be initialized by the synthesis software from the specified file. Chisel does not validate the file contents nor its location. Both the memory initialization file and the Verilog source should be accessible for the toolchain. import chisel3._ import chisel3.util.experimental.loadMemoryFromFileInline class InitMemInline(memoryFile: String = \"\") extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) // Initialize memory if (memoryFile.trim().nonEmpty) { loadMemoryFromFileInline(mem, memoryFile) } io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } The default is to use $readmemh (which assumes all numbers in the file are in ascii hex), but to use ascii binary there is an optional hexOrBinary argument which can be set to MemoryLoadFileType.Hex or MemoryLoadFileType.Binary. You will need to add an additional import. By default, the inline initialization will generate the memory readmem statements inside an ifndef SYNTHESIS block, which suits ASIC workflow. Some synthesis tools (like Synplify and Yosys) define SYNTHESIS so the readmem statement is not read when inside this block. To control this, one can use the MemoryNoSynthInit and MemorySynthInit annotations from firrtl.annotations. The former which is the default setting when no annotation is present generates readmem inside the block. Using the latter, the statement are generated outside the ifndef block so it can be used by FPGA synthesis tools. Below an example for initialization suited for FPGA workflows: import chisel3._ import chisel3.util.experimental.loadMemoryFromFileInline import chisel3.experimental.{annotate, ChiselAnnotation} import firrtl.annotations.MemorySynthInit class InitMemInlineFPGA(memoryFile: String = \"\") extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) // Notice the annotation below annotate(new ChiselAnnotation { override def toFirrtl = MemorySynthInit }) val mem = SyncReadMem(1024, UInt(width.W)) if (memoryFile.trim().nonEmpty) { loadMemoryFromFileInline(mem, memoryFile) } io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } SystemVerilog Bind Initialization Chisel can also initialize memories by generating a SV bind module with readmemh or readmemb statements by using the function loadMemoryFromFile from chisel3.util.experimental. import chisel3._ import chisel3.util.experimental.loadMemoryFromFile class InitMemBind(val bits: Int, val size: Int, filename: String) extends Module { val io = IO(new Bundle { val nia = Input(UInt(bits.W)) val insn = Output(UInt(32.W)) }) val memory = Mem(size, UInt(32.W)) io.insn := memory(io.nia &gt;&gt; 2); loadMemoryFromFile(memory, filename) } Which generates the bind module: module BindsTo_0_Foo( input clock, input reset, input [31:0] io_nia, output [31:0] io_insn ); initial begin $readmemh(\"test.hex\", Foo.memory); end endmodule bind Foo BindsTo_0_Foo BindsTo_0_Foo_Inst(.*); Notes on files There is no simple answer to where to put the hex or bin file with the initial contents. It’s probably best to create a resource directory somewhere and reference that through a full path or place the file beside the generated Verilog. Another option is adding the path to the memory file in the synthesis tool path. Because these files may be large, Chisel does not copy them. Don’t forget there is no decimal option, so a 10 in an input file will be 16 decimal See: ComplexMemoryLoadingSpec.scala and LoadMemoryFromFileSpec.scala for working examples. Aggregate memories Aggregate memories are supported but in bit of a clunky way. Since they will be split up into a memory per field, the following convention was adopted. When specifying the file for such a memory the file name should be regarded as a template. If the memory is a Bundle e.g. class MemDataType extends Bundle { val a = UInt(16.W) val b = UInt(32.W) val c = Bool() } The memory will be split into memory_a, memory_b, and memory_c. Similarly if a load file is specified as \"memory-load.txt\" the simulation will expect that there will be three files, \"memory-load_a.txt\", \"memory-load_b.txt\", \"memory-load_c.txt\" Note: The use of _ and that the memory field name is added before any file suffix. The suffix is optional but if present is considered to be the text after the last . in the file name."
    } ,    
    {
      "title": "Explanations",
      "url": "/chisel3/docs/explanations/explanations.html",
      "content": "Explanations Explanation documentation gives background and context. They can also explain why things are so - design decisions, historical reasons, technical constraints. If you are just getting started with Chisel, we suggest you read these documents in the following order: Motivation Supported Hardware Data Types Bundles and Vecs Combinational Circuits Operators Width Inference Functional Abstraction Ports Modules Sequential Circuits Memories Interfaces and Connections Black Boxes Enumerations Functional Module Creation Muxes and Input Selection Multiple Clock Domains Reset Polymorphism and Paramterization Printing in Chisel Naming Unconnected Wires Annotations"
    } ,    
    {
      "title": "Frequently Asked Questions",
      "url": "/chisel3/docs/resources/faqs.html",
      "content": "Frequently Asked Questions Where should I start if I want to learn Chisel? How do I … in Chisel? What versions of the various projects work together? How can I contribute to Chisel? Why DecoupledIO instead of ReadyValidIO? Why do I have to wrap module instantiations in Module(...)? Why Chisel? Does Chisel support X and Z logic values? I just want some Verilog; what do I do? I just want some FIRRTL; what do I do? Why doesn’t Chisel tell me which wires aren’t connected? What does Reference ... is not fully initialized. mean? Can I specify behavior before and after generated initial blocks? Where should I start if I want to learn Chisel? We recommend the Chisel Bootcamp for getting started with Chisel. How do I do … (e.g. like that in Verilog) in Chisel? See the cookbooks. What versions of the various projects work together? See Chisel Project Versioning. How can I contribute to Chisel? Check out the Contributor Documentation in the chisel3 repository. Why DecoupledIO instead of ReadyValidIO? There are multiple kinds of Ready/Valid interfaces that impose varying restrictions on the producers and consumers. Chisel currently provides the following: DecoupledIO - No guarantees IrrevocableIO - Producer promises to not change the value of ‘bits’ after a cycle where ‘valid’ is high and ‘ready’ is low. Additionally, once ‘valid’ is raised it will never be lowered until after ‘ready’ has also been raised. Why do I have to wrap module instantiations in Module(...)? In short: Limitations of Scala Chisel Modules are written by defining a Scala class and implementing its constructor. As elaboration runs, Chisel constructs a hardware AST from these Modules. The compiler needs hooks to run before and after the actual construction of the Module object. In Scala, superclasses are fully initialized before subclasses, so by extending Module, Chisel has the ability to run some initialization code before the user’s Module is constructed. However, there is no such hook to run after the Module object is initialized. By wrapping Module instantiations in the Module object’s apply method (ie. Module(...)), Chisel is able to perform post-initialization actions. There is a proposed solution, so eventually this requirement will be lifted, but for now, wrap those Modules! Why Chisel? Please see Chisel Motivation Does Chisel support X and Z logic values Chisel does not directly support Verilog logic values x unknown and z high-impedance. There are a number of reasons to want to avoid these values. See:The Dangers of Living With An X and Malicious LUT: A stealthy FPGA Trojan injected and triggered by the design flow. Chisel has its own eco-system of unit and functional testers that limit the need for x and z and their omission simplify language implementation, design, and testing. The circuits created by chisel do not preclude developers from using x and z in downstream toolchains as they see fit. Get me Verilog I wrote a module and I want to see the Verilog; what do I do? Here’s a simple hello world module in a file HelloWorld.scala. package intro import chisel3._ class HelloWorld extends Module { val io = IO(new Bundle{}) printf(\"hello world\\n\") } Add the following import chisel3.stage.ChiselStage object VerilogMain extends App { (new ChiselStage).emitVerilog(new HelloWorld) } Now you can get some Verilog. Start sbt: bash&gt; sbt &gt; run-main intro.VerilogMain [info] Running intro.VerilogMain [info] [0.004] Elaborating design... [info] [0.100] Done elaborating. [success] Total time: 1 s, completed Jan 12, 2017 6:24:03 PM or as a one-liner: bash&gt; sbt 'runMain intro.VerilogMain' After either of the above there will be a HelloWorld.v file in the current directory: module HelloWorld( input clock, input reset ); always @(posedge clock) begin `ifndef SYNTHESIS `ifdef PRINTF_COND if (`PRINTF_COND) begin `endif if (~reset) begin $fwrite(32'h80000002,\"hello world\\n\"); // @[faqs.md 13:9] end `ifdef PRINTF_COND end `endif `endif // SYNTHESIS end endmodule You can see additional options with bash&gt; sbt 'runMain intro.HelloWorld --help' This will return a comprehensive usage line with available options. For example to place the output in a directory name buildstuff use bash&gt; sbt 'runMain intro.HelloWorld --target-dir buildstuff --top-name HelloWorld' Alternatively, you can also use the sbt console to invoke the Verilog driver: $ sbt &gt; console [info] Starting scala interpreter... Welcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275). Type in expressions for evaluation. Or try :help. scala&gt; (new chisel3.stage.ChiselStage).emitVerilog(new HelloWorld()) chisel3.Driver.execute(Array[String](), () =&gt; new HelloWorld) Elaborating design... Done elaborating. res1: String = \"module HelloWorld( input clock, input reset ); ... As before, there should be a HelloWorld.v file in the current directory. Note: Using the following, without the new, will ONLY return the string representation, and will not emit a .v file: ChiselStage.emitVerilog(new HelloWorld()) Get me FIRRTL If for some reason you don’t want the Verilog (e.g. maybe you want to run some custom transformations before exporting to Verilog), then use something along these lines: package intro import chisel3._ import chisel3.stage.ChiselStage class MyFirrtlModule extends Module { val io = IO(new Bundle{}) } object FirrtlMain extends App { (new ChiselStage).emitFirrtl(new MyFirrtlModule) } Run it with: sbt 'runMain intro.FirrtlMain' circuit MyFirrtlModule : module MyFirrtlModule : input clock : Clock input reset : UInt&lt;1&gt; output io : { } skip Alternatively, you can also use the sbt console to invoke the FIRRTL driver directly (replace MyFirrtlModule with your module name): $ sbt &gt; console [info] Starting scala interpreter... Welcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275). Type in expressions for evaluation. Or try :help. scala&gt; (new chisel3.stage.ChiselStage).emitFirrtl(new MyFirrtlModule) Elaborating design... Done elaborating. res3: String = ... Why doesn’t Chisel tell me which wires aren’t connected? As long as your code uses import chisel3._ (and not import Chisel._), it does! See Unconnected Wires for details. What does Reference ... is not fully initialized. mean? It means that you have unconnected wires in your design which could be an indication of a design bug. In Chisel2 compatibility mode (NotStrict compile options), chisel generates firrtl code that disables firrtl’s initialized wire checks. In pure chisel3 (Strict compile options), the generated firrtl code does not contain these disablers (is invalid). Output wires that are not driven (not connected) are reported by firrtl as not fully initialized. Read more at Unconnected Wires for details on solving the problem. Can I specify behavior before and after generated initial blocks? Users may define the following macros if they wish to specify behavior before or after emitted initial blocks. BEFORE_INITIAL, which is called before the emitted (non-empty) initial block if it is defined AFTER_INITIAL, which is called after the emitted (non-empty) initial block if it is defined These macros may be useful for turning coverage on and off."
    } ,    
    {
      "title": "Functional Abstraction",
      "url": "/chisel3/docs/explanations/functional-abstraction.html",
      "content": "Functional Abstraction We can define functions to factor out a repeated piece of logic that we later reuse multiple times in a design. For example, we can wrap up our earlier example of a simple combinational logic block as follows: def clb(a: UInt, b: UInt, c: UInt, d: UInt): UInt = (a &amp; b) | (~c &amp; d) where clb is the function which takes a, b, c, d as arguments and returns a wire to the output of a boolean circuit. The def keyword is part of Scala and introduces a function definition, with each argument followed by a colon then its type, and the function return type given after the colon following the argument list. The equals (=})sign separates the function argument list from the function definition. We can then use the block in another circuit as follows: scala mdoc:silent val out = clb(a,b,c,d)"
    } ,    
    {
      "title": "Functional Module Creation",
      "url": "/chisel3/docs/explanations/functional-module-creation.html",
      "content": "Functional Module Creation Objects in Scala have a pre-existing creation function (method) called apply. When an object is used as value in an expression (which basically means that the constructor was called), this method determines the returned value. When dealing with hardware modules, one would expect the module output to be representative of the hardware module’s functionality. Therefore, we would sometimes like the module output to be the value returned when using the object as a value in an expression. Since hardware modules are represented as Scala objects, this can be done by defining the object’s apply method to return the module’s output. This can be referred to as creating a functional interface for module construction. If we apply this on the standard mux2 example, we would to return the mux2 output ports when we used mux2 in an expression. Implementing this requires building a constructor that takes multiplexer inputs as parameters and returns the multiplexer output: import chisel3._ class Mux2 extends Module { val io = IO(new Bundle { val sel = Input(Bool()) val in0 = Input(UInt()) val in1 = Input(UInt()) val out = Output(UInt()) }) io.out := Mux(io.sel, io.in0, io.in1) } object Mux2 { def apply(sel: UInt, in0: UInt, in1: UInt) = { val m = Module(new Mux2) m.io.in0 := in0 m.io.in1 := in1 m.io.sel := sel m.io.out } } As we can see in the code example, we defined the apply method to take the Mux2 inputs as the method parameters, and return the Mux2 output as the function’s return value. By defining modules in this way, it is easier to later implement larger and more complex version of this regular module. For example, we previously implemented Mux4 like this: class Mux4 extends Module { val io = IO(new Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) }) val m0 = Module(new Mux2) m0.io.sel := io.sel(0) m0.io.in0 := io.in0 m0.io.in1 := io.in1 val m1 = Module(new Mux2) m1.io.sel := io.sel(0) m1.io.in0 := io.in2 m1.io.in1 := io.in3 val m3 = Module(new Mux2) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out m3.io.in1 := m1.io.out io.out := m3.io.out } However, by using the creation function we redefined for Mux2, we can now use the Mux2 outputs as values of the modules themselves when writing the Mux4 output expression: class Mux4 extends Module { val io = IO(new Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) }) io.out := Mux2(io.sel(1), Mux2(io.sel(0), io.in0, io.in1), Mux2(io.sel(0), io.in2, io.in3)) } This allows us to write more intuitively readable hardware connection descriptions, which are similar to software expression evaluation."
    } ,    
    {
      "title": "Testers",
      "url": "/chisel-testers/",
      "content": "Chisel Testers This a layer of test harnesses for Chisel Chisel is an open-source hardware construction language developed at UC Berkeley that supports advanced hardware design using highly parameterized generators and layered domain-specific hardware languages. Visit the community website for more information. The Chisel Tutorials provide many examples of how to use these harnesses The Available Harnesses There are currently three harnesses available. All make it easy to construct a circuit, implemented as chisel Module, named the device under test (or DUT) by specifying what goes into the module’s inputs and what is expected to come out of the module’s outputs. The types of IO ports used by the circuit determines which tester to use. PeekPokeTester Tests the DUT by poking values into its inputs and testing values of its outputs. PeekPokeTester is the most flexible tester, peeks and pokes are done in a software based model. Peeking can be done at any time, and the value returned can be tested and used to take different branches during the text execution. The PeekPokeTester supports two separate backends. The Firrtl Interpreter: a lightweight scala based low firrtl execution engine, with rapid spinup but slower overall speed. A verilator backend: which builds a c++ compiled circuit emulation. Faster execution, but with a longer spinup. This is in contrast to the following hardware oriented testers, in which a testing circuit is built that drives the circuit, or device under test (DUT) from value vectors for each input. Testing the outputs each cycle against a separate set of value vectors for each output. For a longer description, see the Using the PeekPokeTester. SteppedHWIOTester Tests the DUT by poking values into its inputs and testing values of its outputs. Tests are executed in a fixed order and at a fixed cycle For a long description see the Using the Hardware IO Testers OrderedDecoupledHWIOTester Tests a DUT that uses decoupled flow control for its inputs and outputs. Tests values are applied in order mediated by the ready/valid controls. The implementer does not have to manage this flow control."
    } ,      
    {
      "title": "Diagrammer",
      "url": "/diagrammer/",
      "content": "Chisel / FIRRTL Diagramming Project This project can generate GraphViz dot files and from those svg files representing Chisel generated Firrtl circuits. It is also an example of a creating a Firrtl Transformation. This transformation can be applied through the use of annotations as demonstrated in the examples.GCD test. The graphs are mostly clickable, clicking a module will take you to a diagram for just that module. There is a TopLevel diagram that just shows the module hierarchy. Also, an individual arrow can be hovered over to make it turn red and become easier to follow. Example Top Level Example Module Example Using Install Installing this software should be pretty much the following. git clone https://github.com/freechipsproject/diagrammer cd diagrammer Dependencies You will need GraphViz (specifically a default path to the program dot) and sbt. Note that this project currently depends on the master branches of all components of the Chisel ecosystem (chisel3 and firrtl), so you will need to clone and sbt publishLocal for each of these. Creating Circuit Diagrams. To create a set of graphs of a Firrtl Circuit all you need is this project and a Firrtl file (typically a file generated by Chisel with a .fir extension). Let’s say you have a Firrtl file ~/projects/output/circuit.fir. From the command line you while in this directory for this project, you run ./diagram.sh -i ~/projects/output/circuit.fir This will create a number of files in the same directory as the firrtl file that representing the firrtl graph. Each file will be a diagram for each module contained in the firrtl file, plus a file TopLevel.dot.svg file. It will also attempt to open the TopLevel.dot.svg file in a browser using the command open. Each Module in the TopLevel diagram is clickable and should take you into the diagram for that specific module. Because of the size of these files, the diagrams will include the internal logic of that module plus and IO only presentation of any sub-modules found. Options -i, –firrtl-source set the source firrtl to work on -t, –targer-dir sets the output directory for the svg -s, –start-module sets the module name where the graphs will start being generated. The default is at the top -o, –open-program sets the open program, default is open, set to empty to tell it not to do open -j, –just-top-level generates just the top level diagram How Diagrammer Works This program uses a number of firrtl transforms to create multiple graphviz dot file graph programs. The dot files are translated into .svg files. See GeneratorBootcamp Firrtl Chapters for a good introduction to writing Firrtl transforms TODO This used to work by annotating a circuit, consider re-adding that Setting to allow the graphs to go deeper into sub-module logic Provide links to the chisel source"
    } ,      
    {
      "title": "Chisel3",
      "url": "/chisel3/",
      "content": ""
    } ,    
    {
      "title": "FIRRTL",
      "url": "/firrtl/",
      "content": "Flexible Internal Representation for RTL Firrtl is an intermediate representation (IR) for digital circuits designed as a platform for writing circuit-level transformations. This repository consists of a collection of transformations (written in Scala) which simplify, verify, transform, or emit their input circuit. A Firrtl compiler is constructed by chaining together these transformations, then writing the final circuit to a file. For a detailed description of Firrtl’s intermediate representation, see the document “Specification of the Firrtl Language” located in spec/spec.pdf. Wiki Pages and Tutorials Useful information is on our wiki, located here: https://github.com/freechipsproject/firrtl/wiki Some important pages to read, before writing your own transform: Submitting Pull Requests Understanding Firrtl’s IR Traversing a Circuit Common Pass Idioms To write a Firrtl transform, please start with the tutorial here: src/main/scala/tutorial. To run these examples: sbt assembly ./utils/bin/firrtl -td regress -i regress/RocketCore.fir --custom-transforms tutorial.lesson1.AnalyzeCircuit ./utils/bin/firrtl -td regress -i regress/RocketCore.fir --custom-transforms tutorial.lesson2.AnalyzeCircuit Other Tools Firrtl syntax highlighting for Vim users: https://github.com/azidar/firrtl-syntax Firrtl syntax highlighting for Sublime Text 3 users: https://github.com/codelec/highlight-firrtl Firrtl syntax highlighting for Atom users: https://atom.io/packages/language-firrtl Firrtl syntax highlighting, structure view, navigate to corresponding Chisel code for IntelliJ platform: install, source Firrtl mode for Emacs users: https://github.com/ibm/firrtl-mode Chisel3, an embedded hardware DSL that generates Firrtl: https://github.com/freechipsproject/chisel3 Treadle, a Firrtl Interpreter: https://github.com/freechipsproject/treadle Yosys Verilog-to-Firrtl Front-end: https://github.com/cliffordwolf/yosys Installation Instructions Disclaimer: The installation instructions should work for OSX/Linux machines. Other environments may not be tested. Prerequisites If not already installed, install verilator (Requires at least v3.886) If not already installed, install yosys (Requires at least v0.8) If not already installed, install sbt (Requires at least v0.13.6) Installation Clone the repository: git clone https://github.com/freechipsproject/firrtl.git &amp;&amp; cd firrtl Compile firrtl: sbt compile Run tests: sbt test Build executable (utils/bin/firrtl): sbt assembly Note: You can add utils/bin to your path to call firrtl from other processes Publish this version locally in order to satisfy other tool chain library dependencies: sbt publishLocal Useful sbt Tips Run a single test suite: sbt \"testOnly firrtlTests.UnitTests\" Continually execute a command: sbt ~compile Only invoke sbt once: sbt &gt; compile &gt; test Use scalafix to remove unused import and deprecated procedure syntax Remove unused import: sbt \"firrtl/scalafix RemoveUnused\" Remove deprecated procedure syntax sbt \"firrtl/scalafix ProcedureSyntax\" Using Firrtl as a commandline tool utils/bin/firrtl -i regress/rocket.fir -o regress/rocket.v -X verilog // Compiles rocket-chip to Verilog utils/bin/firrtl --help // Returns usage string Using the JQF Fuzzer The build.sbt defines the fuzzer/jqfFuzz and fuzzer/jqfRepro tasks. These can be used to randomly generate and run test cases and reproduce failing test cases respectively. These tasks are Scala implementations of the FuzzGoal and ReproGoal of the JQF maven plugin and should be functionally identical. The format for the arguments to jqfFuzz are as follows: sbt&gt; fuzzer/jqfFuzz &lt;testClassName&gt; &lt;testMethodName&gt; &lt;otherArgs&gt;... The available options are: --classpath &lt;value&gt; the classpath to instrument and load the test class from --outputDirectory &lt;value&gt; the directory to output test results --testClassName &lt;value&gt; the full class path of the test class --testMethod &lt;value&gt; the method of the test class to run --excludes &lt;value&gt; comma-separated list of FQN prefixes to exclude from coverage instrumentation --includes &lt;value&gt; comma-separated list of FQN prefixes to forcibly include, even if they match an exclude --time &lt;value&gt; the duration of time for which to run fuzzing --blind whether to generate inputs blindly without taking into account coverage feedback --engine &lt;value&gt; the fuzzing engine, valid choices are zest|zeal --disableCoverage disable code-coverage instrumentation --inputDirectory &lt;value&gt; the name of the input directory containing seed files --saveAll save ALL inputs generated during fuzzing, even the ones that do not have any unique code coverage --libFuzzerCompatOutput use libFuzzer like output instead of AFL like stats screen --quiet avoid printing fuzzing statistics progress in the console --exitOnCrash stop fuzzing once a crash is found. --runTimeout &lt;value&gt; the timeout for each individual trial, in milliseconds The fuzzer/jqfFuzz sbt task is a thin wrapper around the firrtl.jqf.jqfFuzz main method that provides the --classpath argument and a default --outputDirectory and passes the rest of the arguments to the main method verbatim. The results will be put in the fuzzer/target/JQf/$testClassName/$testMethod directory. Input files in the fuzzer/target/JQf/$testClassName/$testMethod/corpus and fuzzer/target/JQf/$testClassName/$testMethod/failures directories can be passed as inputs to the fuzzer/jqfRepro task. The format for the arguments to jqfRepro are the same as jqfFuzz sbt&gt; fuzzer/jqfRepro &lt;testClassName&gt; &lt;testMethodName&gt; &lt;otherArgs&gt;... The available options are: --classpath &lt;value&gt; the classpath to instrument and load the test class from --testClassName &lt;value&gt; the full class path of the test class --testMethod &lt;value&gt; the method of the test class to run --input &lt;value&gt; input file or directory to reproduce test case(s) --logCoverage &lt;value&gt; output file to dump coverage info --excludes &lt;value&gt; comma-separated list of FQN prefixes to exclude from coverage instrumentation --includes &lt;value&gt; comma-separated list of FQN prefixes to forcibly include, even if they match an exclude --printArgs whether to print the args to each test case Like fuzzer/jqfFuzz, the fuzzer/jqfRepro sbt task is a thin wrapper around the firrtl.jqf.jqfRepro main method that provides the --classpath argument and a default --outputDirectory and passes the rest of the arguments to the main method verbatim. Citing Firrtl If you use Firrtl in a paper, please cite the following ICCAD paper and technical report: https://ieeexplore.ieee.org/document/8203780 @INPROCEEDINGS{8203780, author={A. Izraelevitz and J. Koenig and P. Li and R. Lin and A. Wang and A. Magyar and D. Kim and C. Schmidt and C. Markley and J. Lawson and J. Bachrach}, booktitle={2017 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)}, title={Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations}, year={2017}, volume={}, number={}, pages={209-216}, keywords={field programmable gate arrays;hardware description languages;program compilers;software reusability;hardware development practices;hardware libraries;open-source hardware intermediate representation;hardware compiler transformations;Hardware construction languages;retargetable compilers;software development;virtual Cambrian explosion;hardware compiler frameworks;parameterized libraries;FIRRTL;FPGA mappings;Chisel;Flexible Intermediate Representation for RTL;Reusability;Hardware;Libraries;Hardware design languages;Field programmable gate arrays;Tools;Open source software;RTL;Design;FPGA;ASIC;Hardware;Modeling;Reusability;Hardware Design Language;Hardware Construction Language;Intermediate Representation;Compiler;Transformations;Chisel;FIRRTL}, doi={10.1109/ICCAD.2017.8203780}, ISSN={1558-2434}, month={Nov},} https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-9.html @techreport{Li:EECS-2016-9, Author = {Li, Patrick S. and Izraelevitz, Adam M. and Bachrach, Jonathan}, Title = {Specification for the FIRRTL Language}, Institution = {EECS Department, University of California, Berkeley}, Year = {2016}, Month = {Feb}, URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-9.html}, Number = {UCB/EECS-2016-9} }"
    } ,    
    {
      "title": "ChiselTest",
      "url": "/chiseltest/",
      "content": "ChiselTest formerly known as testers2 This is alpha software that is currently under development, and interfaces may be subject to change (see stability for details). However, it is very much in a usable state, so if you’re fine living on the bleeding edge, give it a try. Overview ChiselTest is a test harness for Chisel-based RTL designs, currently supporting directed testing (all test stimulus manually specified - no constrained random and coverage-driven flows). ChiselTest emphasizes tests that are lightweight (minimizes boilerplate code), easy to read and write (understandability), and compose (for better test code reuse). The core primitives are similar to nonsynthesizable Verilog: input pin assignment (poke), pin value assertion (expect), and time advance (step). Threading concurrency is also supported with the use of fork and join, and concurrent accesses to wires are checked to prevent race conditions. Migrating from chisel-testers / iotesters The core abstractions (poke, expect, step) are similar to chisel-testers, but the syntax is inverted: instead of doing tester.poke(wire, value) with a Scala number value, in ChiselTest you would write wire.poke(value) with a Chisel literal value. Furthermore, as no reference to the tester context is needed, test helper functions can be defined outside a test class and written as libraries. Currently, this should support all the functionality that was in chisel-testers, and provides additional features. This project is meant to supersede chisel-testers, and eventually may become a default part of chisel3. Test cases written in chisel-testers cannot be directly used in ChiselTest, as the syntax is significantly different. Getting Started Installation To use chisel-testers as a managed dependency, add this in your build.sbt: libraryDependencies += \"edu.berkeley.cs\" %% \"chiseltest\" % \"0.2.1\" Note, chiseltest snapshots generally track chisel3 snapshots, and requires the use of a chisel3 snapshot. We may introduce versioned snapshots and releases in the future, tied to a particular release of chisel3. You can also build ChiselTest locally with publishLocal. Writing a Test ChiselTest integrates with the ScalaTest framework, which provides a framework for detection and execution of unit tests. Assuming a typical Chisel project, create a new file in src/test/scala/, for example, BasicTest.scala. In this file: Add the necessary imports: import org.scalatest._ import chiseltest._ import chisel3._ Create a test class: class BasicTest extends FlatSpec with ChiselScalatestTester with Matchers { behavior of \"MyModule\" // test class body here } FlatSpec is the default and recommended ScalaTest style for unit testing. ChiselScalatestTester provides testdriver functionality and integration (like signal value assertions) within the context of a ScalaTest environment. Matchers provides additional syntax options for writing ScalaTest tests. Potentially optional, since it’s mainly for Scala-land assertions and does not inter-operate with circuit operations. In the test class, define a test case: it should \"do something\" in { // test case body here } There can be multiple test cases per test class, and we recommend one test class per Module being tested, and one test case per individual test. In the test case, define the module being tested: test(new MyModule) { c =&gt; // test body here } test automatically runs the default simulator (which is treadle), and runs the test stimulus in the block. The argument to the test stimulus block (c in this case) is a handle to the module under test. In the test body, use poke, step, and expect operations to write the test: c.in.poke(0.U) c.out.expect(0.U) c.in.poke(42.U) c.out.expect(42.U) With your test case complete, you can run all the test cases in your project by invoking ScalaTest. If you’re using sbt, you can either run sbt test from the command line, or test from the sbt console. testOnly can also be used to run specific tests. Usage References See the test cases for examples: BasicTest shows basic peek, poke, and step functionality QueueTest shows example uses of the DecoupledDriver library, providing functions like enqueueNow, expectDequeueNow, their sequence variants, expectPeek, and expectInvalid. Also, check out the DecoupledDriver implementation, and note that it is not a special case, but code that any user can write. BundleLiteralsSpec shows examples of using bundle literals to poke and expect bundle wires. Note: Bundle literals are still an experimental chisel3 feature and need to be explicitly imported: import chisel3.experimental.BundleLiterals._ AlutTest shows an example of re-using the same test for different data ShiftRegisterTest shows an example of using fork/join to define a test helper function, where multiple invocations of it are pipelined using fork. VerilatorBasicTests shows an example using Verilator as the simulator. Note: the simulator is selected by passing an annotation into the test function, which requires experimental imports: import chiseltest.experimental.TestOptionBuilder._ import chiseltest.internal.VerilatorBackendAnnotation test(new MyModule).withAnnotations(Seq(VerilatorBackendAnnotation)) { c =&gt; // test body here } New Constructs fork to spawn threads, and join to block (wait) on a thread. Pokes and peeks/expects to wires from threads are checked during runtime to ensure no collisions or unexpected behavior. forked threads provide a concurrency abstraction for writing testbenches only, without real parallelism. The test infrastructure schedules threads one at a time, with threads running once per simulation cycle. Thread order is deterministic, and attempts to follow lexical order (as it would appear from the code text): forked (child) threads run immediately, then return to the spawning (parent) thread. On future cycles, child threads run before their parent, in the order they were spawned. Only cross-thread operations that round-trip through the simulator (eg, peek-after-poke) are checked. You can do cross-thread operations in Scala (eg, using shared variables) that aren’t checked, but it is up to you to make sure they are correct and intuitive. This is not recommended. In the future, we may provide checked mechanisms for communicating between test threads. Regions can be associated with a thread, with fork.withRegion(...), which act as a synchronization barrier within simulator time steps. This can be used to create monitors that run after other main testdriver threads have been run, and can read wires those threads have poked. timescope allows pokes to be scoped - that is, pokes inside the timescope block “disappear” and the wire reverts to its previous value at the end of the block. This fits well with the pattern of assigning a default pull-up/down to a wire, and temporarily overriding that value, for example a Decoupled valid signal defaulting low but driven high during an enqueue transaction. See TimescopeTest for examples. Quick References To dump VCDs (into the test_run_dir subfolder) using sbt: testOnly chiseltest.tests.BasicTest -- -DwriteVcd=1 Stability These APIs may be considered stable and are unlikely to change significantly: Test invocation test Basic operations: poke, peek, expect, step, including on Bundles Basic concurrency operations: fork, join Decoupled library: enqueueNow, expectDequeueNow, their sequence variants, expectPeek, expectInvalid - though the names may be refactored timescope - though the name may be refactored These are subject to change: Multiclock behavior, which is currently not well defined, including poke on clocks and step when there are multiple clocks. Roadmap These features are on our roadmap, but are not implemented yet. No timeframe is currently available, but feel free to let us know if some feature is critical to your use case in the relevant issue thread, and we may adjust our development priorities accordingly. #14 support for multi-clock designs, and in particular, supporting clock poke to clock step inter-thread dependencies. #28 faster Verilator / VCS testing using mechanisms that avoid interprocess communication, like JNI #58 faster threading (note, unclear if there are good solutions here, especially ones that are fully API compatible - Scala generally lacks good coroutine support) #60, #34, #2 support for testing non-Chisel modules, such as post-syn Verilog, or generally a separation of DUT interface and implementation"
    } ,    
    {
      "title": "Treadle",
      "url": "/treadle/",
      "content": "What is the Treadle Treadle is a hardware circuit simulator that takes its circuit description directly from FIRRTL. It is based on earlier work done in the FirrtlInterpreter. Treadle is most commonly used as a backend for ChiselTest and ChiselTesters unit tests framework. It supports a Peek, Poke, Expect, Step interface. Treadle can be quite a bit slower for very large circuits but it spins up much faster than other backends so for unit tests of small to medium circuits it generally runs considerably faster. Treadle also provides the TreadleRepl, an interactive shell that provides execution and debugging commands."
    } ,    
    {
      "title": "Home",
      "url": "/",
      "content": "Upcoming Events Chisel Dev Meeting Chisel/FIRRTL development meetings happen every Monday and Tuesday from 1100–1200 PT. Call-in info and meeting notes are available here. Chisel Community Conference 2021, Shanghai, China. 6/24/2021 The Chisel Community Conference China 2021 (CCC2021) is planned for June 25, 2021 at the ShanghaiTech University. CCC is an annual gathering of Chisel community enthusiasts and technical exchange workshop. With the support of the Chisel development community, this conference will bring together designers and developers with hands-on experience in Chisel from home and abroad to share cutting-edge results and experiences from the open source community and industry. Session topics include and are not limited to CPU Core (recommended but not restricted to RISC-V) implementations SoC implementations Verification Simulation Synthesis Education Experience sharing Types of manuscripts. Technical Presentations: case studies or problem-oriented presentations on original research, breakthrough ideas, or insights into future trends. Sessions should provide specific examples and include both practical and theoretical information. The length of time is about 20 minutes. Lightning talks: 5 to 10 minutes, either pre-registered or on-site (depending on the time of the conference), can present and promote a specific Chisel project. The presentation submission language is required to be in English, and both English and Chinese are acceptable for the presentation language. Reviewers (subject to change at that time). Jack Koenig Adam Izraelevitz Edward Wang Jiuyang Liu Key Timeline. Submission deadline: April 25, 2021 Manuscript topics and abstracts should be submitted by the submission deadline, and will be reviewed and selected by Chisel developers. Notification of acceptance: by May 12, 2021 Final manuscript deadline: May 30, 2021 A full version of the manuscript should be submitted by the final deadline, and Chisel developers will quality review and suggest final changes. Mail submission method. Subject: - [CCC] Your Topic CC: Jiuyang Liu &lt;liu@jiuyang.me&gt; CC: Jack Koenig &lt;koenig@sifive.com&gt; CC: Adam Izraelevitz &lt;adam.izraelevitz@sifive.com&gt; CC: Edward Wang &lt;edwardw@csail.mit.edu&gt; Body: Abstract of your paper. Attachment: pdf only slides All submissions are welcome. Chisel is a hardware design language that facilitates advanced circuit generation and design reuse for both ASIC and FPGA digital logic designs. Chisel adds hardware construction primitives to the Scala programming language, providing designers with the power of a modern programming language to write complex, parameterizable circuit generators that produce synthesizable Verilog. This generator methodology enables the creation of re-usable components and libraries, such as the FIFO queue and arbiters in the Chisel Standard Library, raising the level of abstraction in design while retaining fine-grained control. For more information on the benefits of Chisel see: “What benefits does Chisel offer over classic Hardware Description Languages?” Chisel is powered by FIRRTL (Flexible Intermediate Representation for RTL), a hardware compiler framework that performs optimizations of Chisel-generated circuits and supports custom user-defined circuit transformations. What does Chisel code look like? Consider an FIR filter that implements a convolution operation, as depicted in this block diagram: While Chisel provides similar base primitives as synthesizable Verilog, and could be used as such: // 3-point moving average implemented in the style of a FIR filter class MovingAverage3(bitWidth: Int) extends Module { val io = IO(new Bundle { val in = Input(UInt(bitWidth.W)) val out = Output(UInt(bitWidth.W)) }) val z1 = RegNext(io.in) val z2 = RegNext(z1) io.out := (io.in * 1.U) + (z1 * 1.U) + (z2 * 1.U) } the power of Chisel comes from the ability to create generators, such as n FIR filter that is defined by the list of coefficients: // Generalized FIR filter parameterized by the convolution coefficients class FirFilter(bitWidth: Int, coeffs: Seq[UInt]) extends Module { val io = IO(new Bundle { val in = Input(UInt(bitWidth.W)) val out = Output(UInt(bitWidth.W)) }) // Create the serial-in, parallel-out shift register val zs = Reg(Vec(coeffs.length, UInt(bitWidth.W))) zs(0) := io.in for (i &lt;- 1 until coeffs.length) { zs(i) := zs(i-1) } // Do the multiplies val products = VecInit.tabulate(coeffs.length)(i =&gt; zs(i) * coeffs(i)) // Sum up the products io.out := products.reduce(_ + _) } and use and re-use them across designs: val movingAverage3Filter = Module(new FirFilter(8, Seq(1.U, 1.U, 1.U))) // same 3-point moving average filter as before val delayFilter = Module(new FirFilter(8, Seq(0.U, 1.U))) // 1-cycle delay as a FIR filter val triangleFilter = Module(new FirFilter(8, Seq(1.U, 2.U, 3.U, 2.U, 1.U))) // 5-point FIR filter with a triangle impulse response The above can be converted to Verilog using ChiselStage: import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation} (new chisel3.stage.ChiselStage).execute( Array(\"-X\", \"verilog\"), Seq(ChiselGeneratorAnnotation(() =&gt; new FirFilter(8, Seq(1.U, 1.U, 1.U))))) Alternatively, you may generate some Verilog directly for inspection: val verilogString = (new chisel3.stage.ChiselStage).emitVerilog(new FirFilter(8, Seq(0.U, 1.U))) println(verilogString) Getting Started Bootcamp Interactive Tutorial The online Chisel Bootcamp is the recommended way to get started with and learn Chisel. No setup is required (it runs in the browser), nor does it assume any prior knowledge of Scala. The classic Chisel tutorial contains small exercises and runs on your computer. A Textbook on Chisel If you like a textbook to learn Chisel and also a bit of digital design in general, you may be interested in reading Digital Design with Chisel. It is available in English, Chinese, Japanese, and Vietnamese. Build Your Own Chisel Projects See the setup instructions for how to set up your environment to run Chisel locally. When you’re ready to build your own circuits in Chisel, we recommend starting from the Chisel Template repository, which provides a pre-configured project, example design, and testbench. Follow the chisel-template readme to get started. If you insist on setting up your own project, the magic SBT lines are: libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.4.0\" libraryDependencies += \"edu.berkeley.cs\" %% \"chiseltest\" % \"0.3.0\" % \"test\" Design Verification These simulation-based verification tools are available for Chisel: iotesters, specifically PeekPokeTester, provides constructs (peek, poke, expect) similar to a non-synthesizable Verilog testbench. testers2 is an in-development replacement for PeekPokeTester, providing the same base constructs but with a streamlined interface and concurrency support with fork and join. Documentation Useful Resources Cheat Sheet, a 2-page reference of the base Chisel syntax and libraries ScalaDoc, a listing, description, and examples of the functionality exposed by Chisel Gitter, where you can ask questions or discuss anything Chisel Website (source) If you are migrating from Chisel2, see the migration guide. Data Types Overview These are the base data types for defining circuit components: Contributor Documentation This section describes how to get started contributing to Chisel itself, including how to test your version locally against other projects that pull in Chisel using sbt’s managed dependencies. Compiling and Testing Chisel First, clone and build the master branch of FIRRTL and Treadle, as the master branch of Chisel may depend on unreleased changes in those projects: git clone https://github.com/chipsalliance/firrtl.git git clone https://github.com/chipsalliance/treadle.git pushd firrtl; sbt publishLocal; popd pushd treadle; sbt publishLocal; popd Clone and build the Chisel library: git clone https://github.com/chipsalliance/chisel3.git cd chisel3 sbt compile If the compilation succeeded, you can then run the included unit tests by invoking: sbt test Running Projects Against Local Chisel To use the development version of Chisel (master branch), you will need to build from source and publishLocal. The repository version can be found in the build.sbt file. As of the time of writing it was: version := \"3.4-SNAPSHOT\" To publish your version of Chisel to the local Ivy (sbt’s dependency manager) repository, run: sbt publishLocal The compiled version gets placed in ~/.ivy2/local/edu.berkeley.cs/. If you need to un-publish your local copy of Chisel, remove the directory generated in ~/.ivy2/local/edu.berkeley.cs/. In order to have your projects use this version of Chisel, you should update the libraryDependencies setting in your project’s build.sbt file to: libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.4-SNAPSHOT\" Building Chisel with FIRRTL in the same SBT Project While we recommend using the library dependency approach as described above, it is possible to build Chisel and FIRRTL in a single SBT project. Caveats This only works for the “main” configuration; you cannot build the Chisel tests this way because treadle is only supported as a library dependency. Do not publishLocal when building this way. The published artifact will be missing the FIRRTL dependency. This works by using sbt-sriracha, an SBT plugin for toggling between source and library dependencies. It provides two JVM system properties that, when set, will tell SBT to include FIRRTL as a source project: sbt.sourcemode - when set to true, SBT will look for FIRRTL in the workspace sbt.workspace - sets the root directory of the workspace Example use: # From root of this repo git clone git@github.com:chipsalliance/firrtl.git sbt -Dsbt.sourcemode=true -Dsbt.workspace=$PWD This is primarily useful for building projects that themselves want to include Chisel as a source dependency. As an example, see Rocket Chip Chisel3 Architecture Overview The Chisel3 compiler consists of these main parts: The frontend, chisel3.*, which is the publicly visible “API” of Chisel and what is used in Chisel RTL. These just add data to the… The Builder, chisel3.internal.Builder, which maintains global state (like the currently open Module) and contains commands, generating… The intermediate data structures, chisel3.firrtl.*, which are syntactically very similar to Firrtl. Once the entire circuit has been elaborated, the top-level object (a Circuit) is then passed to… The Firrtl emitter, chisel3.firrtl.Emitter, which turns the intermediate data structures into a string that can be written out into a Firrtl file for further processing. Also included is: The standard library of circuit generators, chisel3.util.*. These contain commonly used interfaces and constructors (like Decoupled, which wraps a signal with a ready-valid pair) as well as fully parameterizable circuit generators (like arbiters and multiplexors). Chisel Stage, chisel3.stage.*, which contains compilation and test functions that are invoked in the standard Verilog generation and simulation testing infrastructure. These can also be used as part of custom flows. Which version should I use? The chisel eco-system (chisel3, firttl, dsptools, firrtl-interpreter, treadle, diagrammer) use a form of semantic versioning: major versions are identified by two leading numbers, separated by a dot (i.e., 3.2), minor versions by a single number following the major version, separated by a dot. We maintain API compatibility within a major version (i.e., 3.2.12 should be API-compatible with 3.2.0), but do not guarantee API compatibility between major versions (i.e., APIs may change between 3.1.8 and 3.2.0). We may introduce new definitions or add additional parameters to existing definitions in a minor release, but we do our best to maintain compatibility with previous minor releases of a major release - code that worked in 3.2.0 should continue to work un-modified in 3.2.10. We encourage chisel users (rather than chisel developers), to use release versions of chisel. The chisel web site (and GitHub repository) should indicate the current release version. If you encounter an issue with a released version of chisel, please file an issue on GitHub mentioning the chisel version and provide a simple test case (if possible). Try to reproduce the issue with the associated latest minor release (to verify that the issue hasn’t been addressed). If you’re developing a chisel library (or chisel itself), you’ll probably want to work closer to the tip of the development trunk. By default, the master branches of the chisel repositories are configured to build and publish their version of the code as Z.Y-SNAPSHOT. We try to publish an updated SNAPSHOT every two weeks. There is no guarantee of API compatibility between SNAPSHOT versions, but we publish date-stamped Z.Y-yyyymmdd-SNAPSHOT versions which will not change. The code in Z.Y-SNAPSHOT should match the code in the most recent Z.Y-yyyymmdd-SNAPSHOT version, the differences being the chisel library dependencies: Z.Y-SNAPSHOTs depend on V.U-SNAPSHOTs and Z.Y-yyyymmdd-SNAPSHOTs will depend on V.U-yyyymmdd-SNAPSHOTs. NOTE: Prior to the v3.2-20191030-SNAPSHOT version, we used Z.Y-mmddyy-SNAPSHOT to tag and name published SNAPSHOTs. If you’re developing a library (or another chisel tool), you should probably work with date-stamped SNAPSHOTs until your library or tool is ready to be published (to ensure a consistent API). Prior to publishing, you should verify your code against generic (no date-stamp) SNAPSHOTs, or locally published clones of the current master branches of chisel dependencies."
    } ,    
    {
      "title": "Interfaces and Connections",
      "url": "/chisel3/docs/explanations/interfaces-and-connections.html",
      "content": "Interfaces &amp; Bulk Connections For more sophisticated modules it is often useful to define and instantiate interface classes while defining the IO for a module. First and foremost, interface classes promote reuse allowing users to capture once and for all common interfaces in a useful form. Secondly, interfaces allow users to dramatically reduce wiring by supporting bulk connections between producer and consumer modules. Finally, users can make changes in large interfaces in one place reducing the number of updates required when adding or removing pieces of the interface. Note that Chisel has some built-in standard interface which should be used whenever possible for interoperability (e.g. Decoupled). Ports: Subclasses &amp; Nesting As we saw earlier, users can define their own interfaces by defining a class that subclasses Bundle. For example, a user could define a simple link for hand-shaking data as follows: class SimpleLink extends Bundle { val data = Output(UInt(16.W)) val valid = Output(Bool()) } We can then extend SimpleLink by adding parity bits using bundle inheritance: class PLink extends SimpleLink { val parity = Output(UInt(5.W)) } In general, users can organize their interfaces into hierarchies using inheritance. From there we can define a filter interface by nesting two PLinks into a new FilterIO bundle: class FilterIO extends Bundle { val x = Flipped(new PLink) val y = new PLink } where flip recursively changes the direction of a bundle, changing input to output and output to input. We can now define a filter by defining a filter class extending module: class Filter extends Module { val io = IO(new FilterIO) // ... } where the io field contains FilterIO. Bundle Vectors Beyond single elements, vectors of elements form richer hierarchical interfaces. For example, in order to create a crossbar with a vector of inputs, producing a vector of outputs, and selected by a UInt input, we utilize the Vec constructor: import chisel3.util.log2Ceil class CrossbarIo(n: Int) extends Bundle { val in = Vec(n, Flipped(new PLink)) val sel = Input(UInt(log2Ceil(n).W)) val out = Vec(n, new PLink) } where Vec takes a size as the first argument and a block returning a port as the second argument. Bulk Connections We can now compose two filters into a filter block as follows: class Block extends Module { val io = IO(new FilterIO) val f1 = Module(new Filter) val f2 = Module(new Filter) f1.io.x &lt;&gt; io.x f1.io.y &lt;&gt; f2.io.x f2.io.y &lt;&gt; io.y } where &lt;&gt; bulk connects interfaces of opposite gender between sibling modules or interfaces of the same gender between parent/child modules. Bulk connections connect leaf ports of the same name to each other. If the names do not match or are missing, Chisel does not generate a connection. Caution: bulk connections should only be used with directioned elements (like IOs), and is not magical (e.g. connecting two wires isn’t supported since Chisel can’t necessarily figure out the directions automatically chisel3#603). The standard ready-valid interface (ReadyValidIO / Decoupled) Chisel provides a standard interface for ready-valid interfaces. A ready-valid interface consists of a ready signal, a valid signal, and some data stored in bits. The ready bit indicates that a consumer is ready to consume data. The valid bit indicates that a producer has valid data on bits. When both ready and valid are asserted, a data transfer from the producer to the consumer takes place. A convenience method fire is provided that is asserted if both ready and valid are asserted. Usually, we use the utility function Decoupled() to turn any type into a ready-valid interface rather than directly using ReadyValidIO. Decoupled(...) creates a producer / output ready-valid interface (i.e. bits is an output). Flipped(Decoupled(...)) creates a consumer / input ready-valid interface (i.e. bits is an input). Take a look at the following example Chisel code to better understand exactly what is generated: import chisel3._ import chisel3.util.Decoupled /** * Using Decoupled(...) creates a producer interface. * i.e. it has bits as an output. * This produces the following ports: * input io_readyValid_ready, * output io_readyValid_valid, * output [31:0] io_readyValid_bits */ class ProducingData extends Module { val io = IO(new Bundle { val readyValid = Decoupled(UInt(32.W)) }) // do something with io.readyValid.ready io.readyValid.valid := true.B io.readyValid.bits := 5.U } /** * Using Flipped(Decoupled(...)) creates a consumer interface. * i.e. it has bits as an input. * This produces the following ports: * output io_readyValid_ready, * input io_readyValid_valid, * input [31:0] io_readyValid_bits */ class ConsumingData extends Module { val io = IO(new Bundle { val readyValid = Flipped(Decoupled(UInt(32.W))) }) io.readyValid.ready := false.B // do something with io.readyValid.valid // do something with io.readyValid.bits } DecoupledIO is a ready-valid interface with the convention that there are no guarantees placed on deasserting ready or valid or on the stability of bits. That means ready and valid can also be deasserted without a data transfer. IrrevocableIO is a ready-valid interface with the convention that the value of bits will not change while valid is asserted and ready is deasserted. Also the consumer shall keep ready asserted after a cycle where ready was high and valid was low. Note that the irrevocable constraint is only a convention and cannot be enforced by the interface. Chisel does not automatically generate checkers or assertions to enforce the irrevocable convention."
    } ,    
    {
      "title": "Introduction",
      "url": "/chisel3/docs/introduction.html",
      "content": "An Introduction to Chisel Chisel (Constructing Hardware In a Scala Embedded Language) is a hardware construction language embedded in the high-level programming language Scala. Chisel is a library of special class definitions, predefined objects, and usage conventions within Scala, so when you write Chisel you are actually writing a Scala program that constructs a hardware graph. As you gain experience and want to make your code simpler or more reusable, you will find it important to leverage the underlying power of the Scala language. We recommend you consult one of the excellent Scala books to become more expert in Scala programming. For a tutorial covering both Chisel and Scala, see the online Chisel Bootcamp. For quick reference “How-To” guides see the Cookbooks. For a deeper introduction to key concepts in Chisel see the Explanations. The API Documentation gives the detailed reference for the Chisel source code. Note that previous versions can be found via the sidebar menu at [https://www.chisel-lang.org/chisel3]. The Resources provides links to other useful resources for learning and working with Chisel. The Appendix covers some more advanced topics. The Developers section provides information for those working on the Chisel library itself. Throughout these pages, we format commentary on our design choices as in this paragraph. You should be able to skip the commentary sections and still fully understand how to use Chisel, but we hope you’ll find them interesting."
    } ,    
    {
      "title": "Memories",
      "url": "/chisel3/docs/explanations/memories.html",
      "content": "Memories Chisel provides facilities for creating both read only and read/write memories. ROM Users can define read-only memories by constructing a Vec with VecInit. VecInit can except either a variable-argument number of Data literals or a Seq[Data] literals that initialize the ROM. For example, users can create a small ROM initialized to 1, 2, 4, 8 and loop through all values using a counter as an address generator as follows: val m = VecInit(1.U, 2.U, 4.U, 8.U) val r = m(counter(m.length.U)) We can create an n value sine lookup table using a ROM initialized as follows: def sinTable(amp: Double, n: Int) = { val times = (0 until n).map(i =&gt; (i*2*Pi)/(n.toDouble-1) - Pi) val inits = times.map(t =&gt; Math.round(amp * sin(t)).asSInt(32.W)) VecInit(inits) } def sinWave(amp: Double, n: Int) = sinTable(amp, n)(counter(n.U)) where amp is used to scale the fixpoint values stored in the ROM. Read-Write Memories Memories are given special treatment in Chisel since hardware implementations of memory vary greatly. For example, FPGA memories are instantiated quite differently from ASIC memories. Chisel defines a memory abstraction that can map to either simple Verilog behavioural descriptions or to instances of memory modules that are available from external memory generators provided by foundry or IP vendors. SyncReadMem: sequential/synchronous-read, sequential/synchronous-write Chisel has a construct called SyncReadMem for sequential/synchronous-read, sequential/synchronous-write memories. These SyncReadMems will likely be synthesized to technology SRAMs (as opposed to register banks). If the same memory address is both written and sequentially read on the same clock edge, or if a sequential read enable is cleared, then the read data is undefined. Values on the read data port are not guaranteed to be held until the next read cycle. If that is the desired behavior, external logic to hold the last read value must be added. Read port/write port Ports into SyncReadMems are created by applying a UInt index. A 1024-entry SRAM with one write port and one read port might be expressed as follows: import chisel3._ class ReadWriteSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) // Create one write port and one read port mem.write(io.addr, io.dataIn) io.dataOut := mem.read(io.addr, io.enable) } Below is an example waveform of the one write port/one read port SyncReadMem with masks. Note that the signal names will differ from the exact wire names generated for the SyncReadMem. With masking, it is also possible that multiple RTL arrays will be generated with the behavior below. Single-ported Single-ported SRAMs can be inferred when the read and write conditions are mutually exclusive in the same when chain: import chisel3._ class RWSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val dataIn = Input(UInt(width.W)) val dataOut = Output(UInt(width.W)) }) val mem = SyncReadMem(1024, UInt(width.W)) io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { rdwrPort := io.dataIn } .otherwise { io.dataOut := rdwrPort } } } (The DontCare is there to make Chisel’s unconnected wire detection aware that reading while writing is undefined.) Here is an example single read/write port waveform, with masks (again, generated signal names and number of arrays may differ): Mem: combinational/asynchronous-read, sequential/synchronous-write Chisel supports random-access memories via the Mem construct. Writes to Mems are combinational/asynchronous-read, sequential/synchronous-write. These Mems will likely be synthesized to register banks, since most SRAMs in modern technologies (FPGA, ASIC) tend to no longer support combinational (asynchronous) reads. Creating asynchronous-read versions of the examples above simply involves replacing SyncReadMem with Mem. Masks Chisel memories also support write masks for subword writes. Chisel will infer masks if the data type of the memory is a vector. To infer a mask, specify the mask argument of the write function which creates write ports. A given masked length is written if the corresponding mask bit is set. For example, in the example below, if the 0th bit of mask is true, it will write the lower byte of the data at corresponding address. import chisel3._ class MaskedReadWriteSmem extends Module { val width: Int = 8 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val addr = Input(UInt(10.W)) val mask = Input(Vec(4, Bool())) val dataIn = Input(Vec(4, UInt(width.W))) val dataOut = Output(Vec(4, UInt(width.W))) }) // Create a 32-bit wide memory that is byte-masked val mem = SyncReadMem(1024, Vec(4, UInt(width.W))) // Write with mask mem.write(io.addr, io.dataIn, io.mask) io.dataOut := mem.read(io.addr, io.enable) } Here is an example of masks with readwrite ports: import chisel3._ class MaskedRWSmem extends Module { val width: Int = 32 val io = IO(new Bundle { val enable = Input(Bool()) val write = Input(Bool()) val mask = Input(Vec(2, Bool())) val addr = Input(UInt(10.W)) val dataIn = Input(Vec(2, UInt(width.W))) val dataOut = Output(Vec(2, UInt(width.W))) }) val mem = SyncReadMem(1024, Vec(2, UInt(width.W))) io.dataOut := DontCare when(io.enable) { val rdwrPort = mem(io.addr) when (io.write) { when(io.mask(0)) { rdwrPort(0) := io.dataIn(0) } when(io.mask(1)) { rdwrPort(1) := io.dataIn(1) } }.otherwise { io.dataOut := rdwrPort } } } Memory Initialization Chisel memories can be initialized from an external binary or hex file emitting proper Verilog for synthesis or simulation. There are multiple modes of initialization. For more information, check the experimental docs on Loading Memories feature."
    } ,    
    {
      "title": "Modules",
      "url": "/chisel3/docs/explanations/modules.html",
      "content": "Modules Chisel modules are very similar to Verilog modules in defining a hierarchical structure in the generated circuit. The hierarchical module namespace is accessible in downstream tools to aid in debugging and physical layout. A user-defined module is defined as a class which: inherits from Module, contains an interface wrapped in a Module’s IO() method and stored in a port field named io, and wires together subcircuits in its constructor. As an example, consider defining your own two-input multiplexer as a module: import chisel3._ class Mux2IO extends Bundle { val sel = Input(UInt(1.W)) val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val out = Output(UInt(1.W)) } class Mux2 extends Module { val io = IO(new Mux2IO) io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0) } The wiring interface to a module is a collection of ports in the form of a Bundle. The interface to the module is defined through a field named io. For Mux2, io is defined as a bundle with four fields, one for each multiplexer port. The := assignment operator, used here in the body of the definition, is a special operator in Chisel that wires the input of left-hand side to the output of the right-hand side. Module Hierarchy We can now construct circuit hierarchies, where we build larger modules out of smaller sub-modules. For example, we can build a 4-input multiplexer module in terms of the Mux2 module by wiring together three 2-input multiplexers: class Mux4IO extends Bundle { val in0 = Input(UInt(1.W)) val in1 = Input(UInt(1.W)) val in2 = Input(UInt(1.W)) val in3 = Input(UInt(1.W)) val sel = Input(UInt(2.W)) val out = Output(UInt(1.W)) } class Mux4 extends Module { val io = IO(new Mux4IO) val m0 = Module(new Mux2) m0.io.sel := io.sel(0) m0.io.in0 := io.in0 m0.io.in1 := io.in1 val m1 = Module(new Mux2) m1.io.sel := io.sel(0) m1.io.in0 := io.in2 m1.io.in1 := io.in3 val m3 = Module(new Mux2) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out m3.io.in1 := m1.io.out io.out := m3.io.out } We again define the module interface as io and wire up the inputs and outputs. In this case, we create three Mux2 children modules, using the Module constructor function and the Scala new keyword to create a new object. We then wire them up to one another and to the ports of the Mux4 interface. Note: Chisel Modules have an implicit clock (called clock) and an implicit reset (called reset). For different behavior, Chisel provides both MultiIOModule and RawModule. MultiIOModule A MultiIOModule allows you to define as many different IO as needed and does not require you to implement an abstract member io. This can be useful when programmatically adding IO or adding IO via inheritance. An artifact of this is that Verilog generated from a MultiIOModule will not have the io_ prefix. MultiIOModules still have an implicit clock and reset like Module. RawModule A RawModule is a module that allows you to define as much IO as needed (like MultiIOModule) but does not provide an implicit clock and reset. This can be useful when interfacing a Chisel module with a design that expects a specific naming convention for clock or reset. Then we can use it in place of Module usage : import chisel3.{RawModule, withClockAndReset} class Foo extends Module { val io = IO(new Bundle{ val a = Input(Bool()) val b = Output(Bool()) }) io.b := !io.a } class FooWrapper extends RawModule { val a_i = IO(Input(Bool())) val b_o = IO(Output(Bool())) val clk = IO(Input(Clock())) val rstn = IO(Input(Bool())) val foo = withClockAndReset(clk, !rstn){ Module(new Foo) } foo.io.a := a_i b_o := foo.io.b } In the example above, the RawModule is used to change the reset polarity of module SlaveSpi. Indeed, the reset is active high by default in Chisel modules, then using withClockAndReset(clock, !rstn) we can use an active low reset in entire design. The clock is just wired as it, but if needed, RawModule can be used in conjunction with BlackBox to connect a differential clock input for example."
    } ,    
    {
      "title": "Motivation",
      "url": "/chisel3/docs/explanations/motivation.html",
      "content": "Motivation – “Why Chisel?” We were motivated to develop a new hardware language by years of struggle with existing hardware description languages in our research projects and hardware design courses. Verilog and VHDL were developed as hardware simulation languages, and only later did they become a basis for hardware synthesis. Much of the semantics of these languages are not appropriate for hardware synthesis and, in fact, many constructs are simply not synthesizable. Other constructs are non-intuitive in how they map to hardware implementations, or their use can accidentally lead to highly inefficient hardware structures. While it is possible to use a subset of these languages and still get acceptable results, they nonetheless present a cluttered and confusing specification model, particularly in an instructional setting. However, our strongest motivation for developing a new hardware language is our desire to change the way that electronic system design takes place. We believe that it is important to not only teach students how to design circuits, but also to teach them how to design circuit generators —programs that automatically generate designs from a high-level set of design parameters and constraints. Through circuit generators, we hope to leverage the hard work of design experts and raise the level of design abstraction for everyone. To express flexible and scalable circuit construction, circuit generators must employ sophisticated programming techniques to make decisions concerning how to best customize their output circuits according to high-level parameter values and constraints. While Verilog and VHDL include some primitive constructs for programmatic circuit generation, they lack the powerful facilities present in modern programming languages, such as object-oriented programming, type inference, support for functional programming, and reflection. Instead of building a new hardware design language from scratch, we chose to embed hardware construction primitives within an existing language. We picked Scala not only because it includes the programming features we feel are important for building circuit generators, but because it was specifically developed as a base for domain-specific languages."
    } ,    
    {
      "title": "Multiple Clock Domains",
      "url": "/chisel3/docs/explanations/multi-clock.html",
      "content": "Chisel 3 supports multiple clock domains as follows. Note that in order to cross clock domains safely, you will need appropriate synchronization logic (such as an asynchronous FIFO). You can use the AsyncQueue library to do this easily. import chisel3._ class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val resetB = Input(Bool()) val stuff = Input(Bool()) }) // This register is clocked against the module clock. val regClock = RegNext(io.stuff) withClockAndReset (io.clockB, io.resetB) { // In this withClock scope, all synchronous elements are clocked against io.clockB. // Reset for flops in this domain is using the explicitly provided reset io.resetB. // This register is clocked against io.clockB. val regClockB = RegNext(io.stuff) } // This register is also clocked against the module clock. val regClock2 = RegNext(io.stuff) } You can also instantiate modules in another clock domain: import chisel3._ class ChildModule extends Module { val io = IO(new Bundle{ val in = Input(Bool()) }) } class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val resetB = Input(Bool()) val stuff = Input(Bool()) }) val clockB_child = withClockAndReset(io.clockB, io.resetB) { Module(new ChildModule) } clockB_child.io.in := io.stuff } If you only want to connect your clock to a new clock domain and use the regular implicit reset signal, you can use withClock(clock) instead of withClockAndReset. import chisel3._ class MultiClockModule extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val stuff = Input(Bool()) }) // This register is clocked against the module clock. val regClock = RegNext(io.stuff) withClock (io.clockB) { // In this withClock scope, all synchronous elements are clocked against io.clockB. // This register is clocked against io.clockB, but uses implict reset from the parent context. val regClockB = RegNext(io.stuff) } // This register is also clocked against the module clock. val regClock2 = RegNext(io.stuff) } // Instantiate module in another clock domain with implicit reset. class MultiClockModule2 extends Module { val io = IO(new Bundle { val clockB = Input(Clock()) val stuff = Input(Bool()) }) val clockB_child = withClock(io.clockB) { Module(new ChildModule) } clockB_child.io.in := io.stuff } class ChildModule extends Module { val io = IO(new Bundle{ val in = Input(Bool()) }) }"
    } ,    
    {
      "title": "Muxes and Input Selection",
      "url": "/chisel3/docs/explanations/muxes-and-input-selection.html",
      "content": "Muxes and Input Selection Selecting inputs is very useful in hardware description, and therefore Chisel provides several built-in generic input-selection implementations. Mux The first one is Mux. This is a 2-input selector. Unlike the Mux2 example which was presented previously, the built-in Mux allows the inputs (in0 and in1) to be any datatype as long as they are the same subclass of Data. By using the functional module creation feature presented in the previous section, we can create multi-input selector in a simple way: Mux(c1, a, Mux(c2, b, Mux(..., default))) MuxCase The nested Mux is not necessary since Chisel also provides the built-in MuxCase, which implements that exact feature. MuxCase is an n-way Mux, which can be used as follows: MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...)) Where each selection dependency is represented as a tuple in a Scala array [ condition -&gt; selected_input_port ]. MuxLookup Chisel also provides MuxLookup which is an n-way indexed multiplexer: MuxLookup(idx, default, Array(0.U -&gt; a, 1.U -&gt; b, ...)) This is the same as a MuxCase, where the conditions are all index based selection: MuxCase(default, Array((idx === 0.U) -&gt; a, (idx === 1.U) -&gt; b, ...)) Note that the conditions/cases/selectors (eg. c1, c2) must be in parentheses. Mux1H Another Mux utility is the one-hot mux, Mux1H. It takes a sequence of selectors and values and returns the value associated with the one selector that is set. If zero or multiple selectors are set the behavior is undefined. For example: val hotValue = chisel3.util.Mux1H(Seq( io.selector(0) -&gt; 2.U, io.selector(1) -&gt; 4.U, io.selector(2) -&gt; 8.U, io.selector(4) -&gt; 11.U, )) Mux1H whenever possible generates Firrtl that is readily optimizable as low depth and/or tree. This optimization is not possible when the values are of type FixedPoint or an aggregate type that contains FixedPoints and results instead as a simple Mux tree. This behavior could be sub-optimal. As FixedPoint is still experimental this behavior may change in the future."
    } ,    
    {
      "title": "Naming Cookbook",
      "url": "/chisel3/docs/cookbooks/naming.html",
      "content": "I still have _T signals, can this be fixed? First check - is the compiler plugin properly enabled? Scalac plugins are enabled via the scalac option -Xplugin:&lt;path/to/jar&gt;. You can check which compiler plugins are enabled by running show Compile / scalacOptions in the sbt prompt. If the plugin is enabled, these signals could be intermediate values which are consumed by either assertions or when predicates. In these cases, the compiler plugin often can’t find a good prefix for the generated intermediate signals. We recommend you manually insert calls to prefix to fix these cases. We did this to Rocket Chip and saw huge benefits! I still see _GEN signals, can this be fixed? _GEN signals are usually generated from the FIRRTL compiler, rather than the Chisel library. We are working on renaming these signals with more context-dependent names, but it is a work in progress. Thanks for caring! My module names are super unstable - I change one thing and Queue_1 becomes Queue_42. Help! This is the infamous Queue instability problem. In general, these cases are best solved at the source - the module itself! If you overwrite desiredName to include parameter information (see the explanation for more info), then this can avoid this problem permanantly. We’ve done this with some Chisel utilities with great results! I want to add some hardware or assertions, but each time I do all the signal names get bumped! This is the classic “ECO” problem, and we provide descriptions in explanation. In short, we recommend wrapping all additional logic in a prefix scope, which enables a unique namespace. This should prevent name collisions, which are what triggers all those annoying signal name bumps! I want to force a signal (or instance) name to something, how do I do that? Use the .suggestName method, which is on all classes which subtype Data. All this prefixing is annoying, how do I fix it? You can use the noPrefix { ... } to strip the prefix from all signals generated in that scope. class ExampleNoPrefix extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = noPrefix { in + in + in } out := add } module ExampleNoPrefix( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] _T_1 = in + in; // @[naming.md 27:27] assign out = _T_1 + in; // @[naming.md 27:32] endmodule I am still not getting the name I want. For example, inlining an instance changes my name! In cases where a FIRRTL transform renames a signal/instance, you can use the forcename API: import chisel3.util.experimental.{forceName, InlineInstance} class WrapperExample extends MultiIOModule { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val inst = Module(new Wrapper) inst.in := in out := inst.out } class Wrapper extends MultiIOModule with InlineInstance { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) val inst = Module(new MyLeaf) forceName(inst, \"inst\") inst.in := in out := inst.out } class MyLeaf extends MultiIOModule { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt(3.W))) out := in } module MyLeaf( input [2:0] in, output [2:0] out ); assign out = in; // @[naming.md 67:7] endmodule module WrapperExample( input clock, input reset, input [2:0] in, output [2:0] out ); wire [2:0] inst_in; wire [2:0] inst_out; wire [2:0] inst_in; // @[naming.md 57:20] wire [2:0] inst_out; // @[naming.md 57:20] MyLeaf inst ( // @[naming.md 57:20] .in(inst_in), .out(inst_out) ); assign inst_out = inst_out; // @[naming.md 60:7] assign inst_in = inst_in; // @[naming.md 59:11] assign out = inst_out; // @[naming.md 50:7] assign inst_in = in; // @[naming.md 49:11] endmodule This can be used to rename instances and non-aggregate typed signals."
    } ,    
    {
      "title": "Naming",
      "url": "/chisel3/docs/explanations/naming.html",
      "content": "Historically, Chisel has had trouble reliably capturing the names of signals. The reasons for this are due to (1) primarily relying on reflection to find names, (2) using @chiselName macro which had unreliable behavior. Chisel 3.4 introduced a custom Scala compiler plugin which enables reliabe and automatic capturing of signal names, when they are declared. In addition, this release includes prolific use of a new prefixing API which enables more stable naming of signals programmatically generated from function calls. This document explains how naming now works in Chisel for signal and module names. For cookbook examples on how to fix systemic name-stability issues, please refer to the naming cookbook. Compiler Plugin // Imports used by the following examples import chisel3._ import chisel3.experimental.{prefix, noPrefix} import chisel3.stage.ChiselStage With the release of Chisel 3.4, users should add the following line to their build.sbt settings to get the improved naming: // chiselVersion is the String version (eg. \"3.4.0\") addCompilerPlugin(\"edu.berkeley.cs\" % \"chisel3-plugin\" % chiselVersion cross CrossVersion.full) This plugin will run after the ‘typer’ phase of the Scala compiler. It looks for any user code which is of the form val x = y, where x is of type chisel3.Data, chisel3.MemBase, or chisel3.experimental.BaseModule. For each line which fits this criteria, it rewrites that line. In the following examples, the commented line is the what the line above is rewritten to. If the line is within a bundle declaration or is a module instantiation, it is rewritten to replace the right hand side with a call to autoNameRecursively, which names the signal/module. class MyBundle extends Bundle { val foo = Input(UInt(3.W)) // val foo = autoNameRecursively(\"foo\")(Input(UInt(3.W))) } class Example1 extends MultiIOModule { val io = IO(new MyBundle()) // val io = autoNameRecursively(\"io\")(IO(new MyBundle())) } module Example1( input clock, input reset, input [2:0] io_foo ); endmodule Otherwise, it is rewritten to also include the name as a prefix to any signals generated while executing the right-hand- side of the val declaration: class Example2 extends MultiIOModule { val in = IO(Input(UInt(2.W))) // val in = autoNameRecursively(\"in\")(prefix(\"in\")(IO(Input(UInt(2.W))))) val out = IO(Output(UInt(2.W))) // val out = autoNameRecursively(\"out\")(prefix(\"out\")(IO(Output(UInt(2.W))))) def inXin() = in * in val add = 3.U + inXin() // val add = autoNameRecursively(\"add\")(prefix(\"add\")(3.U + inXin())) // Note that the intermediate result of the multiplication is prefixed with `add` out := add + 1.U } module Example2( input clock, input reset, input [1:0] in, output [1:0] out ); wire [3:0] _add_T = in * in; // @[naming.md 48:20] wire [3:0] add = 4'h3 + _add_T; // @[naming.md 50:17] wire [3:0] _out_T_1 = add + 4'h1; // @[naming.md 54:14] assign out = _out_T_1[1:0]; // @[naming.md 54:7] endmodule Note that the naming also works if the hardware type is nested in an Option or a subtype of Iterable: class Example3 extends MultiIOModule { val in = IO(Input(UInt(2.W))) // val in = autoNameRecursively(\"in\")(prefix(\"in\")(IO(Input(UInt(2.W))))) val out = IO(Output(UInt())) // val out = autoNameRecursively(\"out\")(prefix(\"out\")(IO(Output(UInt(2.W))))) def inXin() = in * in val opt = Some(3.U + inXin()) // Note that the intermediate result of the inXin() is prefixed with `opt`: // val opt = autoNameRecursively(\"opt\")(prefix(\"opt\")(Some(3.U + inXin()))) out := opt.get + 1.U } module Example3( input clock, input reset, input [1:0] in, output [3:0] out ); wire [3:0] _opt_T = in * in; // @[naming.md 74:20] wire [3:0] opt = 4'h3 + _opt_T; // @[naming.md 76:22] assign out = opt + 4'h1; // @[naming.md 80:18] endmodule There is also a slight variant (autoNameRecursivelyProduct) for naming hardware with names provided by an unapply: class UnapplyExample extends MultiIOModule { def mkIO() = (IO(Input(UInt(2.W))), IO(Output(UInt()))) val (in, out) = mkIO() // val (in, out) = autoNameRecursivelyProduct(List(Some(\"in\"), Some(\"out\")))(mkIO()) out := in } module UnapplyExample( input clock, input reset, input [1:0] in, output [1:0] out ); assign out = in; // @[naming.md 98:7] endmodule Note that the compiler plugin will not insert a prefix in these cases because it is ambiguous what the prefix should be. Users who desire a prefix are encouraged to provide one as described below. Prefixing As shown above, the compiler plugin automatically attempts to prefix some of your signals for you. However, you as a user can also add your own prefixes. This is especially for ECO-type fixes where you need to add some logic to a module but don’t want to influence other names in the module. In the following example, we prefix additional logic with “ECO”, where Example4 is pre-ECO and Example5 is post-ECO: class Example4 extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = in + in + in out := add + 1.U } class Example5 extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = in + in + in out := prefix(\"ECO\") { add + 1.U + in } } module Example4( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] _add_T_1 = in + in; // @[naming.md 115:16] wire [1:0] add = _add_T_1 + in; // @[naming.md 115:21] assign out = add + 2'h1; // @[naming.md 117:14] endmodule module Example5( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] _add_T_1 = in + in; // @[naming.md 125:16] wire [1:0] add = _add_T_1 + in; // @[naming.md 125:21] wire [1:0] _out_ECO_T_1 = add + 2'h1; // @[naming.md 127:30] assign out = _out_ECO_T_1 + in; // @[naming.md 127:36] endmodule Also note that the prefixes append to each other (including the prefix generated by the compiler plugin): class Example6 extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = prefix(\"foo\") { in + in + in } out := add } module Example6( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] _add_foo_T_1 = in + in; // @[naming.md 147:32] assign out = _add_foo_T_1 + in; // @[naming.md 147:37] endmodule Sometimes you may want to disable the prefixing. This might occur if you are writing a library function and don’t want the prefixing behavior. In this case, you can use the noPrefix object: class Example7 extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = noPrefix { in + in + in } out := add } module Example7( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] _T_1 = in + in; // @[naming.md 166:27] assign out = _T_1 + in; // @[naming.md 166:32] endmodule Suggest a Signal’s Name (or the instance name of a Module) If you want to specify the name of a signal, you can always use the .suggestName API. Please note that the suggested name will still be prefixed (including by the plugin). You can always use the noPrefix object to strip this. class Example8 extends MultiIOModule { val in = IO(Input(UInt(2.W))) val out = IO(Output(UInt())) val add = (in + (in + in).suggestName(\"foo\")) out := add } module Example8( input clock, input reset, input [1:0] in, output [1:0] out ); wire [1:0] add_foo = in + in; // @[naming.md 185:23] assign out = in + add_foo; // @[naming.md 185:17] endmodule Set a Module Name If you want to specify the module’s name (not the instance name of a module), you can always override the desiredName value. Note that you can parameterize the name by the module’s parameters. This is an excellent way to make your module names more stable and is highly recommended to do. class Example9(width: Int) extends MultiIOModule { override val desiredName = s\"EXAMPLE9WITHWIDTH$width\" val in = IO(Input(UInt(width.W))) val out = IO(Output(UInt())) val add = (in + (in + in).suggestName(\"foo\")) out := add } module EXAMPLE9WITHWIDTH8( input clock, input reset, input [7:0] in, output [7:0] out ); wire [7:0] add_foo = in + in; // @[naming.md 205:23] assign out = in + add_foo; // @[naming.md 205:17] endmodule module EXAMPLE9WITHWIDTH1( input clock, input reset, input in, output out ); wire add_foo = in + in; // @[naming.md 205:23] assign out = in + add_foo; // @[naming.md 205:17] endmodule Reflection Naming Regardless of whether the compiler plugin is enabled or not, after Chisel constructs a module, it attempts to name all members of the Module. This will name all vals which are fields of the module class, but it will not name any vals in nested functions or scopes. If the plugin successfully names a signal, the reflection naming will do nothing. We plan to deprecate all reflection naming in a future Chisel release, but are leaving it to allow the plugin naming to be optional (but recommended). For example, the signals in the following module are in a nested scope; the plugin successfully names them, but reflection naming cannot: class Example10 extends MultiIOModule { { val in = IO(Input(UInt(3.W))) val out = IO(Output(UInt())) val add = in + in out := add } } @chiselName This macro is no longer recommended as its functionality is entirely replaced by the compiler plugin. Feel free to delete from your Chisel designs!"
    } ,    
    {
      "title": "Operators",
      "url": "/chisel3/docs/explanations/operators.html",
      "content": "Chisel Operators Chisel defines a set of hardware operators: Operation Explanation Bitwise operators Valid on: SInt, UInt, Bool val invertedX = ~x Bitwise NOT val hiBits = x &amp; \"h_ffff_0000\".U Bitwise AND val flagsOut = flagsIn \\| overflow Bitwise OR val flagsOut = flagsIn ^ toggle Bitwise XOR Bitwise reductions. Valid on: SInt and UInt. Returns Bool. val allSet = x.andR AND reduction val anySet = x.orR OR reduction val parity = x.xorR XOR reduction Equality comparison. Valid on: SInt, UInt, and Bool. Returns Bool. val equ = x === y Equality val neq = x =/= y Inequality Shifts Valid on: SInt and UInt val twoToTheX = 1.S &lt;&lt; x Logical shift left val hiBits = x &gt;&gt; 16.U Right shift (logical on UInt and arithmetic on SInt). Bitfield manipulation Valid on: SInt, UInt, and Bool. val xLSB = x(0) Extract single bit, LSB has index 0. val xTopNibble = x(15, 12) Extract bit field from end to start bit position. val usDebt = Fill(3, \"hA\".U) Replicate a bit string multiple times. val float = Cat(sign, exponent, mantissa) Concatenates bit fields, with first argument on left. Logical Operations Valid on: Bool val sleep = !busy Logical NOT val hit = tagMatch &amp;&amp; valid Logical AND val stall = src1busy || src2busy Logical OR val out = Mux(sel, inTrue, inFalse) Two-input mux where sel is a Bool Arithmetic operations Valid on Nums: SInt and UInt. val sum = a + b or val sum = a +% b Addition (without width expansion) val sum = a +&amp; b Addition (with width expansion) val diff = a - b or val diff = a -% b Subtraction (without width expansion) val diff = a -&amp; b Subtraction (with width expansion) val prod = a * b Multiplication val div = a / b Division val mod = a % b Modulus Arithmetic comparisons Valid on Nums: SInt and UInt. Returns Bool. val gt = a &gt; b Greater than val gte = a &gt;= b Greater than or equal val lt = a &lt; b Less than val lte = a &lt;= b Less than or equal Our choice of operator names was constrained by the Scala language. We have to use triple equals=== for equality and =/= for inequality to allow the native Scala equals operator to remain usable. The Chisel operator precedence is not directly defined as part of the Chisel language. Practically, it is determined by the evaluation order of the circuit, which natuarally follows the Scala operator precedence. If in doubt of operator precedence, use parentheses. The Chisel/Scala operator precedence is similar but not identical to precedence in Java or C. Verilog has the same operator precedence as C, but VHDL does not. Verilog has precedence ordering for logic operations, but in VHDL those operators have the same precedence and are evaluated from left to right."
    } ,      
    {
      "title": "Polymorphism and Parameterization",
      "url": "/chisel3/docs/explanations/polymorphism-and-parameterization.html",
      "content": "Polymorphism and Parameterization This section is advanced and can be skipped at first reading. Scala is a strongly typed language and uses parameterized types to specify generic functions and classes. In this section, we show how Chisel users can define their own reusable functions and classes using parameterized classes. Parameterized Functions Earlier we defined Mux2 on Bool, but now we show how we can define a generic multiplexer function. We define this function as taking a boolean condition and con and alt arguments (corresponding to then and else expressions) of type T: def Mux[T &lt;: Bits](c: Bool, con: T, alt: T): T = { ... } where T is required to be a subclass of Bits. Scala ensures that in each usage of Mux, it can find a common superclass of the actual con and alt argument types, otherwise it causes a Scala compilation type error. For example, Mux(c, UInt(10), UInt(11)) yields a UInt wire because the con and alt arguments are each of type UInt. Parameterized Classes Like parameterized functions, we can also parameterize classes to make them more reusable. For instance, we can generalize the Filter class to use any kind of link. We do so by parameterizing the FilterIO class and defining the constructor to take a single argument gen of type T as below. class FilterIO[T &lt;: Data](gen: T) extends Bundle { val x = Input(gen) val y = Output(gen) } We can now define Filter by defining a module class that also takes a link type constructor argument and passes it through to the FilterIO interface constructor: class Filter[T &lt;: Data](gen: T) extends Module { val io = IO(new FilterIO(gen)) // ... } We can now define a PLink-based Filter as follows: val f = Module(new Filter(new PLink)) A generic FIFO could be defined as follows: import chisel3.util.log2Up class DataBundle extends Bundle { val a = UInt(32.W) val b = UInt(32.W) } class Fifo[T &lt;: Data](gen: T, n: Int) extends Module { val io = IO(new Bundle { val enqVal = Input(Bool()) val enqRdy = Output(Bool()) val deqVal = Output(Bool()) val deqRdy = Input(Bool()) val enqDat = Input(gen) val deqDat = Output(gen) }) val enqPtr = RegInit(0.U((log2Up(n)).W)) val deqPtr = RegInit(0.U((log2Up(n)).W)) val isFull = RegInit(false.B) val doEnq = io.enqRdy &amp;&amp; io.enqVal val doDeq = io.deqRdy &amp;&amp; io.deqVal val isEmpty = !isFull &amp;&amp; (enqPtr === deqPtr) val deqPtrInc = deqPtr + 1.U val enqPtrInc = enqPtr + 1.U val isFullNext = Mux(doEnq &amp;&amp; ~doDeq &amp;&amp; (enqPtrInc === deqPtr), true.B, Mux(doDeq &amp;&amp; isFull, false.B, isFull)) enqPtr := Mux(doEnq, enqPtrInc, enqPtr) deqPtr := Mux(doDeq, deqPtrInc, deqPtr) isFull := isFullNext val ram = Mem(n, gen) when (doEnq) { ram(enqPtr) := io.enqDat } io.enqRdy := !isFull io.deqVal := !isEmpty ram(deqPtr) &lt;&gt; io.deqDat } An Fifo with 8 elements of type DataBundle could then be instantiated as: val fifo = Module(new Fifo(new DataBundle, 8)) It is also possible to define a generic decoupled (ready/valid) interface: class DecoupledIO[T &lt;: Data](data: T) extends Bundle { val ready = Input(Bool()) val valid = Output(Bool()) val bits = Output(data) } This template can then be used to add a handshaking protocol to any set of signals: class DecoupledDemo extends DecoupledIO(new DataBundle) The FIFO interface can be now be simplified as follows: class Fifo[T &lt;: Data](data: T, n: Int) extends Module { val io = IO(new Bundle { val enq = Flipped(new DecoupledIO(data)) val deq = new DecoupledIO(data) }) // ... } Parametrization based on Modules You can also parametrize modules based on other modules rather than just types. The following is an example of a module parametrized by other modules as opposed to e.g. types. import chisel3.RawModule import chisel3.experimental.BaseModule import chisel3.stage.ChiselStage // Provides a more specific interface since generic Module // provides no compile-time information on generic module's IOs. trait MyAdder { def in1: UInt def in2: UInt def out: UInt } class Mod1 extends RawModule with MyAdder { val in1 = IO(Input(UInt(8.W))) val in2 = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) out := in1 + in2 } class Mod2 extends RawModule with MyAdder { val in1 = IO(Input(UInt(8.W))) val in2 = IO(Input(UInt(8.W))) val out = IO(Output(UInt(8.W))) out := in1 - in2 } class X[T &lt;: BaseModule with MyAdder](genT: =&gt; T) extends Module { val io = IO(new Bundle { val in1 = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val subMod = Module(genT) io.out := subMod.out subMod.in1 := io.in1 subMod.in2 := io.in2 } println(ChiselStage.emitVerilog(new X(new Mod1))) println(ChiselStage.emitVerilog(new X(new Mod2))) Output: module Mod1( input [7:0] in1, input [7:0] in2, output [7:0] out ); assign out = in1 + in2; // @[polymorphism-and-parameterization.md 174:16] endmodule module X( input clock, input reset, input [7:0] io_in1, input [7:0] io_in2, output [7:0] io_out ); wire [7:0] subMod_in1; // @[polymorphism-and-parameterization.md 192:24] wire [7:0] subMod_in2; // @[polymorphism-and-parameterization.md 192:24] wire [7:0] subMod_out; // @[polymorphism-and-parameterization.md 192:24] Mod1 subMod ( // @[polymorphism-and-parameterization.md 192:24] .in1(subMod_in1), .in2(subMod_in2), .out(subMod_out) ); assign io_out = subMod_out; // @[polymorphism-and-parameterization.md 193:12] assign subMod_in1 = io_in1; // @[polymorphism-and-parameterization.md 194:16] assign subMod_in2 = io_in2; // @[polymorphism-and-parameterization.md 195:16] endmodule module Mod2( input [7:0] in1, input [7:0] in2, output [7:0] out ); assign out = in1 - in2; // @[polymorphism-and-parameterization.md 182:16] endmodule module X( input clock, input reset, input [7:0] io_in1, input [7:0] io_in2, output [7:0] io_out ); wire [7:0] subMod_in1; // @[polymorphism-and-parameterization.md 192:24] wire [7:0] subMod_in2; // @[polymorphism-and-parameterization.md 192:24] wire [7:0] subMod_out; // @[polymorphism-and-parameterization.md 192:24] Mod2 subMod ( // @[polymorphism-and-parameterization.md 192:24] .in1(subMod_in1), .in2(subMod_in2), .out(subMod_out) ); assign io_out = subMod_out; // @[polymorphism-and-parameterization.md 193:12] assign subMod_in1 = io_in1; // @[polymorphism-and-parameterization.md 194:16] assign subMod_in2 = io_in2; // @[polymorphism-and-parameterization.md 195:16] endmodule"
    } ,    
    {
      "title": "Ports",
      "url": "/chisel3/docs/explanations/ports.html",
      "content": "Ports Ports are used as interfaces to hardware components. A port is simply any Data object that has directions assigned to its members. Chisel provides port constructors to allow a direction to be added (input or output) to an object at construction time. Primitive port constructors wrap the type of the port in Input or Output. An example port declaration is as follows: class Decoupled extends Bundle { val ready = Output(Bool()) val data = Input(UInt(32.W)) val valid = Input(Bool()) } After defining Decoupled, it becomes a new type that can be used as needed for module interfaces or for named collections of wires. By folding directions into the object declarations, Chisel is able to provide powerful wiring constructs described later. Inspecting Module ports (Chisel 3.2+) Chisel 3.2+ introduces an API DataMirror.modulePorts which can be used to inspect the IOs of any Chisel module, including MultiIOModules, RawModules, and BlackBoxes. Here is an example of how to use this API: import chisel3.experimental.DataMirror import chisel3.stage.{ChiselGeneratorAnnotation, ChiselStage} class Adder extends MultiIOModule { val a = IO(Input(UInt(8.W))) val b = IO(Input(UInt(8.W))) val c = IO(Output(UInt(8.W))) c := a +&amp; b } class Test extends MultiIOModule { val adder = Module(new Adder) // for debug only adder.a := DontCare adder.b := DontCare // Inspect ports of adder // See the result below. DataMirror.modulePorts(adder).foreach { case (name, port) =&gt; { println(s\"Found port $name: $port\") }} } (new ChiselStage).execute(Array.empty, Seq(ChiselGeneratorAnnotation(() =&gt; new Test))) // Elaborating design... // Found port clock: Clock(IO clock in Adder) // Found port reset: Reset(IO reset in Adder) // Found port a: UInt&lt;8&gt;(IO a in Adder) // Found port b: UInt&lt;8&gt;(IO b in Adder) // Found port c: UInt&lt;8&gt;(IO c in Adder) // Done elaborating. // res0: firrtl.AnnotationSeq = firrtl.AnnotationSeq@77997fd2"
    } ,    
    {
      "title": "Printing",
      "url": "/chisel3/docs/explanations/printing.html",
      "content": "Printing in Chisel Chisel provides the printf function for debugging purposes. It comes in two flavors: Scala-style C-style Scala-style Chisel also supports printf in a style similar to Scala’s String Interpolation. Chisel provides a custom string interpolator p which can be used as follows: val myUInt = 33.U printf(p\"myUInt = $myUInt\") // myUInt = 33 Note that when concatenating p\"...\" strings, you need to start with a p\"...\" string: // Does not interpolate the second string val myUInt = 33.U printf(\"my normal string\" + p\"myUInt = $myUInt\") Simple formatting Other formats are available as follows: val myUInt = 33.U // Hexadecimal printf(p\"myUInt = 0x${Hexadecimal(myUInt)}\") // myUInt = 0x21 // myUInt = 0x21 // Binary printf(p\"myUInt = ${Binary(myUInt)}\") // myUInt = 100001 // myUInt = 100001 // Character printf(p\"myUInt = ${Character(myUInt)}\") // myUInt = ! We recognize that the format specifiers are verbose, so we are working on a more concise syntax. Aggregate data-types Chisel provides default custom “pretty-printing” for Vecs and Bundles. The default printing of a Vec is similar to printing a Seq or List in Scala while printing a Bundle is similar to printing a Scala Map. val myVec = VecInit(5.U, 10.U, 13.U) printf(p\"myVec = $myVec\") // myVec = Vec(5, 10, 13) // myVec = Vec(5, 10, 13) val myBundle = Wire(new Bundle { val foo = UInt() val bar = UInt() }) myBundle.foo := 3.U myBundle.bar := 11.U printf(p\"myBundle = $myBundle\") // myBundle = Bundle(a -&gt; 3, b -&gt; 11) Custom Printing Chisel also provides the ability to specify custom printing for user-defined Bundles. class Message extends Bundle { val valid = Bool() val addr = UInt(32.W) val length = UInt(4.W) val data = UInt(64.W) override def toPrintable: Printable = { val char = Mux(valid, 'v'.U, '-'.U) p\"Message:\\n\" + p\" valid : ${Character(char)}\\n\" + p\" addr : 0x${Hexadecimal(addr)}\\n\" + p\" length : $length\\n\" + p\" data : 0x${Hexadecimal(data)}\\n\" } } val myMessage = Wire(new Message) myMessage.valid := true.B myMessage.addr := \"h1234\".U myMessage.length := 10.U myMessage.data := \"hdeadbeef\".U printf(p\"$myMessage\") Which prints the following: Message: valid : v addr : 0x00001234 length : 10 data : 0x00000000deadbeef Notice the use of + between p interpolated “strings”. The results of p interpolation can be concatenated by using the + operator. For more information, please see the documentation C-Style Chisel provides printf in a similar style to its C namesake. It accepts a double-quoted format string and a variable number of arguments which will then be printed on rising clock edges. Chisel supports the following format specifiers: Format Specifier Meaning %d decimal number %x hexadecimal number %b binary number %c 8-bit ASCII character %% literal percent It also supports a small set of escape characters: Escape Character Meaning \\n newline \\t tab \\\" literal double quote \\' literal single quote \\\\ literal backslash Note that single quotes do not require escaping, but are legal to escape. Thus printf can be used in a way very similar to how it is used in C: val myUInt = 32.U printf(\"myUInt = %d\", myUInt) // myUInt = 32"
    } ,    
    {
      "title": "Reset",
      "url": "/chisel3/docs/explanations/reset.html",
      "content": "Reset As of Chisel 3.2.0, Chisel 3 supports both synchronous and asynchronous reset, meaning that it can natively emit both synchronous and asynchronously reset registers. The type of register that is emitted is based on the type of the reset signal associated with the register. There are three types of reset that implement a common trait Reset: Bool - constructed with Bool(). Also known as “synchronous reset”. AsyncReset - constructed with AsyncReset(). Also known as “asynchronous reset”. Reset - constructed with Reset(). Also known as “abstract reset”. For implementation reasons, the concrete Scala type is ResetType. Stylistically we avoid ResetType, instead using the common trait Reset. Registers with reset signals of type Bool are emitted as synchronous reset flops. Registers with reset signals of type AsyncReset are emitted as asynchronouly reset flops. Registers with reset signals of type Reset will have their reset type inferred during FIRRTL compilation. Reset Inference FIRRTL will infer a concrete type for any signals of type abstract Reset. The rules are as follows: An abstract Reset with only signals of type AsyncReset, abstract Reset, and DontCare in both its fan-in and fan-out will infer to be of type AsyncReset An abstract Reset with signals of both types Bool and AsyncReset in its fan-in and fan-out is an error. Otherwise, an abstract Reset will infer to type Bool. You can think about (3) as the mirror of (1) replacing AsyncReset with Bool with the additional rule that abstract Resets with neither AsyncReset nor Bool in their fan-in and fan-out will default to type Bool. This “default” case is uncommon and implies that reset signal is ultimately driven by a DontCare. Implicit Reset A Module’s reset is of type abstract Reset. Prior to Chisel 3.2.0, the type of this field was Bool. For backwards compatability, if the top-level module has an implicit reset, its type will default to Bool. Setting Implicit Reset Type New in Chisel 3.3.0 If you would like to set the reset type from within a Module (including the top-level Module), rather than relying on Reset Inference, you can mixin one of the following traits: RequireSyncReset - sets the type of reset to Bool RequireAsyncReset - sets the type of reset to AsyncReset For example: class MyAlwaysSyncResetModule extends MultiIOModule with RequireSyncReset { val mySyncResetReg = RegInit(false.B) // reset is of type Bool } class MyAlwaysAsyncResetModule extends MultiIOModule with RequireAsyncReset { val myAsyncResetReg = RegInit(false.B) // reset is of type AsyncReset } Note: This sets the concrete type, but the Scala type will remain Reset, so casting may still be necessary. This comes up most often when using a reset of type Bool in logic. Reset-Agnostic Code The purpose of abstract Reset is to make it possible to design hardware that is agnostic to the reset discipline used. This enables code reuse for utilities and designs where the reset discipline does not matter to the functionality of the block. Consider the two example modules below which are agnostic to the type of reset used within them: class ResetAgnosticModule extends Module { val io = IO(new Bundle { val out = UInt(4.W) }) val resetAgnosticReg = RegInit(0.U(4.W)) resetAgnosticReg := resetAgnosticReg + 1.U io.out := resetAgnosticReg } class ResetAgnosticRawModule extends RawModule { val clk = IO(Input(Clock())) val rst = IO(Input(Reset())) val out = IO(Output(UInt(8.W))) val resetAgnosticReg = withClockAndReset(clk, rst)(RegInit(0.U(8.W))) resetAgnosticReg := resetAgnosticReg + 1.U out := resetAgnosticReg } These modules can be used in both synchronous and asynchronous reset domains. Their reset types will be inferred based on the context within which they are used. Forcing Reset Type You can set the type of a Module’s implicit reset as described above. You can also cast to force the concrete type of reset. .asBool will reinterpret a Reset as Bool .asAsyncReset will reinterpret a Reset as AsyncReset. You can then use withReset to use a cast reset as the implicit reset. See “Multiple Clock Domains” for more information about withReset. The following will make myReg as well as both resetAgnosticRegs synchronously reset: class ForcedSyncReset extends MultiIOModule { // withReset's argument becomes the implicit reset in its scope withReset (reset.asBool) { val myReg = RegInit(0.U) val myModule = Module(new ResetAgnosticModule) // RawModules do not have implicit resets so withReset has no effect val myRawModule = Module(new ResetAgnosticRawModule) // We must drive the reset port manually myRawModule.rst := Module.reset // Module.reset grabs the current implicit reset } } The following will make myReg as well as both resetAgnosticRegs asynchronously reset: class ForcedAysncReset extends MultiIOModule { // withReset's argument becomes the implicit reset in its scope withReset (reset.asAsyncReset){ val myReg = RegInit(0.U) val myModule = Module(new ResetAgnosticModule) // myModule.reset is connected implicitly // RawModules do not have implicit resets so withReset has no effect val myRawModule = Module(new ResetAgnosticRawModule) // We must drive the reset port manually myRawModule.rst := Module.reset // Module.reset grabs the current implicit reset } } Note: such casts (asBool and asAsyncReset) are not checked by FIRRTL. In doing such a cast, you as the designer are effectively telling the compiler that you know what you are doing and to force the type as cast. Last-Connect Semantics It is not legal to override the reset type using last-connect semantics unless you are overriding a DontCare: class MyModule extends MultiIOModule { val resetBool = Wire(Reset()) resetBool := DontCare resetBool := false.B // this is fine withReset(resetBool) { val mySubmodule = Module(new Submodule()) } resetBool := true.B // this is fine resetBool := false.B.asAsyncReset // this will error in FIRRTL }"
    } ,    
    {
      "title": "Resources and References",
      "url": "/chisel3/docs/resources/resources.html",
      "content": "Chisel Resources The best resource to learn about Chisel is the online Chisel Bootcamp. This runs in your browser and assumes no prior Scala knowledge. (You may also run this locally via the backing chisel-bootcamp GitHub repository.) When you’re ready to build your own circuits in Chisel, we recommend starting from the Chisel Template repository, which provides a pre-configured project, example design, and testbench. Follow the chisel-template readme to get started. The following additional resources and references may be useful: Chisel Cheatsheet Digital Design With Chisel Frequently Asked Questions"
    } ,    
    {
      "title": "Developers",
      "url": "/chisel3/docs/developers/sbt-subproject.html",
      "content": "Chisel as an sbt subproject In order to use the constructs defined in the Chisel3 library, those definitions must be made available to the Scala compiler at the time a project dependent on them is compiled. For sbt-based builds there are fundamentally two ways to do this: provide a library dependency on the published Chisel3 jars via sbt’s libraryDependencies setting, clone the Chisel3 git repository and include the source code as a subproject of a dependent project. The former of these two approaches is used by the chisel-tutorial project. It is the simplest approach and assumes you do not require tight control over Chisel3 source code and are content with the published release versions of Chisel3. The latter approach should be used by Chisel3 projects that require finer control over Chisel3 source code. It’s hard to predict in advance the future requirements of a project, and it would be advantageous to be able to switch between the two approaches relatively easily. In order to accomplish this, we provide the sbt-chisel-dep plugin that allows the developer to concisely specify Chisel3 subproject dependencies and switch between subproject and library dependency support based on the presence of a directory (or symbolic link) in the root of the dependent project. The chisel-template project uses this plugin to support switching between either dependency (subproject or library). By default, the chisel-template project does not contain a chisel3 subproject directory, and hence, uses a library dependency on chisel3 (and related Chisel3 projects). However, if you clone the chisel3 GitHub project from the root directory of the chisel-template project, creating a chisel3 subdirectory, the sbt-chisel-dep plugin will take note of the chisel3 project subdirectory, and provide an sbt subproject dependency in place of the library dependency. Checkout the README for the sbt-chisel-dep project for instructions on its usage. Example versions of the build.sbt and specification of the sbt-chisel-dep plugin are available from the skeleton branch of the chisel-template repository."
    } ,      
    {
      "title": "Sequential Circuits",
      "url": "/chisel3/docs/explanations/sequential-circuits.html",
      "content": "Sequential Circuits The simplest form of state element supported by Chisel is a positive edge-triggered register, which can be instantiated as: val reg = RegNext(in) This circuit has an output that is a copy of the input signal in delayed by one clock cycle. Note that we do not have to specify the type of Reg as it will be automatically inferred from its input when instantiated in this way. In the current version of Chisel, clock and reset are global signals that are implicitly included where needed. Note that registers which do not specify an initial value will not change value upon toggling the reset signal. Using registers, we can quickly define a number of useful circuit constructs. For example, a rising-edge detector that takes a boolean signal in and outputs true when the current value is true and the previous value is false is given by: def risingedge(x: Bool) = x &amp;&amp; !RegNext(x) Counters are an important sequential circuit. To construct an up-counter that counts up to a maximum value, max, then wraps around back to zero (i.e., modulo max+1), we write: def counter(max: UInt) = { val x = RegInit(0.asUInt(max.getWidth.W)) x := Mux(x === max, 0.U, x + 1.U) x } The counter register is created in the counter function with a reset value of 0 (with width large enough to hold max), to which the register will be initialized when the global reset for the circuit is asserted. The := assignment to x in counter wires an update combinational circuit which increments the counter value unless it hits the max at which point it wraps back to zero. Note that when x appears on the right-hand side of an assignment, its output is referenced, whereas when on the left-hand side, its input is referenced. Counters can be used to build a number of useful sequential circuits. For example, we can build a pulse generator by outputting true when a counter reaches zero: // Produce pulse every n cycles. def pulse(n: UInt) = counter(n - 1.U) === 0.U A square-wave generator can then be toggled by the pulse train, toggling between true and false on each pulse: // Flip internal state when input true. def toggle(p: Bool) = { val x = RegInit(false.B) x := Mux(p, !x, x) x } // Square wave of a given period. def squareWave(period: UInt) = toggle(pulse(period &gt;&gt; 1))"
    } ,    
    {
      "title": "Style Guide",
      "url": "/chisel3/docs/developers/style.html",
      "content": "Chisel Developers Style Guide This document describes the syle used within the chisel3 and related projects (firrtl, treadle, etc). It does not capture requirements for code which is written using these libraries, although projects may choose to adopt these guidelines. The Chisel style guide reflects the Google Java style guide and the General Public Scala style guide. The specific rules below are to clarify the style used for the chisel3 repo and repos related to Chisel (Firrtl). Goal: Readability and consistency are the main purposes of the style guide. Writing your code so someone else (or yourself) can grok it later is important to code health and quality. Filenames The source file name consists of the case-sensitive name of the top-level class it contains, plus “.scala”. Packages Package definitions must contain the full path to the package from scala. If you create a subpackage, it should go in a subdirectory. package directory.name.to.get.you.to.your.source As in Scala, packages follow the Java package naming convention. Note that these guidelines call for all lowercase, no underscores. // Do this package hardware.chips.topsecret.masterplan // Not this package hardware.chips.veryObvious.bad_style We also suggest you do not use chisel3 as a package, and especially do not use it as the final (innermost) package. // Don't do this package hardware.chips.newchip.superfastcomponent.chisel3 // This will lead to instantiating package members like so: val module = Module(new chisel3.FastModule) // Which collides with the chisel namespace import chisel3._ Imports Avoid wildcard ( ._ ) imports, with the exception of chisel3._ All other imports must call out used methods. import chisel3._ must be first, and separated from remaining imports with an extra blank line. Reason: This makes it clear where methods are defined. Any remaining imports must be listed alphabetically. import chisel3._ import the.other.thing.that.i.reference.inline import the.other.things.that.i.reference.{ClassOne, ClassTwo} val myInline = inline.MakeAnInline() val myClassOne = new ClassOne Tests Test classes are named starting with the name of the class they are testing, and ending with “Test”. Test files must start with the name of the class you are testing and end with “Test.scala”. Test files should reside in a subdirectory called “tests”. The tests package should be composed of the package class you are testing. package class.under.test.class package tests Comments We use scaladoc to automatically generate documentation from the source code. /** Multiple lines of ScalaDoc text are written here, * wrapped normally... */ public int method(String p1) { ... } … or in this single-line example: /** An especially short bit of Javadoc. */ Write documentation as if the person reading it knows more about Scala and Chisel than you. If you find comments in the code consider breaking them up into seperate methods. Module Classes and Instances Modules can take different forms in Chisel. The first form is similar to Verilog, where you instance the module and then hook it up. In this case Module(new MyMod()) is returning a reference to the module. val myMod = Module(new MyMod()) myMod.io &lt;&gt; hookUp The second form is a more programmatic inline style with factory methods. In this case, Queue is actually returning the part of the IO bundle representing the queue’s output. The factory method takes the input IO to the queue and an optional parameter for depth. val queueOut = Queue(queueIn, depth=10) The latter can be used for composing multiple functions into a single line. val queueOut = Queue( Arbitrate.byRoundRobin( Queue(a), // depth assumed to be 1 Queue(b, depth=3), Queue(c, depth=4) ), depth=10 ) Naming Conventions Chisel follows the Scala Naming Conventions. In general, Chisel code should use lowerCamelCase for variable naming (ie. the first letter of each word is capitalized except for the first word) and UpperCamelCase for class names. Using these guidelines can result in verilog which is noncompliant with common verilog coding standards, e.g. the lowRISC verilog coding style. Authors of Chisel code that translates to hardware constructs might therefore prefer to use snake_case. However, generated code can always be transformed to meet various emitted code requirements, so the official Chisel style guide follows the Scala convention. Why CamelCase instead of Snake_Case? The compiler inserts underscores when splitting Chisel/FIRRTL aggregate types into Verilog types. The compiler uses underscores to preserve the original structure of the data in the resulting Verilog. Because of the special meaning of underscores in Chisel-generated Verilog, their use in naming is strongly discouraged. Consider the following Chisel code: val msg = Wire(new Bundle { val valid = Bool() val addr = UInt(32) val data = UInt(64) }) val msg_rec = Wire(Bool()) Which compiles to the Verilog: wire msg_valid; wire [31:0] msg_addr; wire [63:0] msg_data; wire msg_rec; The Verilog maintains the structure of the original aggregate wire msg. However, because we named another variable msg_rec, it appears in the Verilog as if msg had 4 fields instead of its actual 3! If we instead follow the lowerCamelCase for values naming convention, the resulting Verilog makes more sense: val msg = Wire(new Bundle { val valid = Bool() val addr = UInt(32) val data = UInt(64) }) val msgRec = Wire(Bool()) And its resulting Verilog: wire msg_valid; wire [31:0] msg_addr; wire [63:0] msg_data; wire msgRec; Much better. Modules and Bundles (Classes, Traits, and Objects) Modules are Scala classes and thus use UpperCamelCase. class ModuleNamingExample extends Module { ... } Similarly, other classes (Chisel &amp; Scala) should be UpperCamelCase as well. trait UsefulScalaUtilities { def isEven(n: Int): Boolean = (n % 2) == 0 def isOdd(n: Int): Boolean = !isEven(n) } class MyCustomBundle extends Bundle { ... } // Companion object to MyCustomBundle object MyCustomBundle { ... } Values and Methods Values and methods should use lowerCamelCase. (Unless the value is a constant.) val mySuperReg = Reg(init = 0.asUInt(32)) def myImportantMethod(a: UInt): Bool = a &lt; 23.asUInt Constants Unlike the Google Java style, constants use UpperCamelCase, which is in line with the official Scala Naming Conventions. Constants are final fields (val or object) whose contents are deeply immutable and belong to a package object or an object. Examples: // Constants object Constants { val Number = 5 val Names = \"Ed\" :: \"Ann\" :: Nil val Ages = Map(\"Ed\" -&gt; 35, \"Ann\" -&gt; 32) } // Not constants class NonConstantsInClass { val inClass: String = \"in-class\" } object nonConstantsInObject { var varString = \"var-string\" val mutableCollection: scala.collection.mutable.Set[String] val mutableElements = Set(mutable) } UpperCamelCase vs. lowerCamelCase There is more than one reasonable way to covert English prose into camel case. We follow the convention defined in the Google Java style guide. The potentially non-obvious rule being to treat acronymns as words for the purpose of camel case. Note that the casing of the original words is almost entirely disregarded. Example: Prose form UpperCamelCase lowerCamelCase Incorrect find GCD FindGcd findGcd findGCD state for FSM StateForFsm stateForFsm stateForFSM mock dut MockDut mockDut MockDUT FIFO Generator FifoGenerator fifoGenerator FIFOGenerator"
    } ,    
    {
      "title": "Supported Hardware",
      "url": "/chisel3/docs/explanations/supported-hardware.html",
      "content": "Supported Hardware While Chisel focuses on binary logic, Chisel can support analog and tri-state wires with the Analog type - see Datatypes in Chisel. We focus on binary logic designs as they constitute the vast majority of designs in practice. Tri-state logic are poorly supported standard industry flows and require special/controlled hard macros in order to be done."
    } ,    
    {
      "title": "Test Coverage",
      "url": "/chisel3/docs/developers/test-coverage.html",
      "content": "Test Coverage Test Coverage Setup Chisel’s sbt build instructions contain the requisite plug-in (sbt-scoverage) for generating test coverage information. Please see the sbt-scoverage web page for details on the plug-in. The tests themselves are found in src/test/scala. Generating A Test Coverage Report Use the following sequence of sbt commands to generate a test coverage report: sbt clean coverage test sbt coverageReport The coverage reports should be found in target/scala-x.yy/scoverage-report/{scoverage.xml,index.html} where x.yy corresponds to the version of Scala used to compile Firrtl and the tests. scoverage.xml is useful if you want to analyze the results programmatically. index.html is designed for navigation with a web browser, allowing one to drill down to invidual statements covered (or not) by the tests."
    } ,    
    {
      "title": "Troubleshooting",
      "url": "/chisel3/docs/cookbooks/troubleshooting.html",
      "content": "Troubleshooting This page is a starting point for recording common and not so common problems in developing with Chisel3. In particular, those situations where there is a work around that will keep you going. type mismatch specifying width/value of a UInt/SInt I have some old code that used to work correctly in chisel2 (and still does if I use the import Chisel._ compatibility layer) but causes a type mismatch error in straight chisel3: class TestBlock extends Module { val io = IO(new Bundle { val output = Output(UInt(width=3)) }) } produces type mismatch; [error] found : Int(3) [error] required: chisel3.internal.firrtl.Width [error] val output = Output(UInt(width=3)) The single argument, multi-function object/constructors from chisel2 have been removed from chisel3. It was felt these were too prone to error and made it difficult to diagnose error conditions in chisel3 code. In chisel3, the single argument to the UInt/SInt object/constructor specifies the width and must be a Width type. Although there are no automatic conversions from Int to Width, an Int may be converted to a Width by applying the W method to an Int. In chisel3, the above code becomes: import chisel3._ class TestBlock extends Module { val io = IO(new Bundle { val output = Output(UInt(3.W)) }) } UInt/SInt literals may be created from an Int with the application of either the U or S method. UInt(42) // error: overloaded method value apply with alternatives: // (range: chisel3.internal.firrtl.IntervalRange)chisel3.UInt &lt;and&gt; // (width: chisel3.internal.firrtl.Width)chisel3.UInt // cannot be applied to (Int) // UInt(42) // ^^^^ in chisel2, becomes 42.U in chisel3 A literal with a specific width is created by calling the U or S method with a W argument. Use: 1.S(8.W) to create an 8-bit wide (signed) literal with value 1."
    } ,    
    {
      "title": "Unconnected Wires",
      "url": "/chisel3/docs/explanations/unconnected-wires.html",
      "content": "Unconnected Wires The Invalidate API (#645) adds support to Chisel for reporting unconnected wires as errors. Prior to this pull request, Chisel automatically generated a firrtl is invalid for Module IO(), and each Wire() definition. This made it difficult to detect cases where output signals were never driven. Chisel now supports a DontCare element, which may be connected to an output signal, indicating that that signal is intentionally not driven. Unless a signal is driven by hardware or connected to a DontCare, Firrtl will complain with a “not fully initialized” error. API Output signals may be connected to DontCare, generating a is invalid when the corresponding firrtl is emitted. class Out extends Bundle { val debug = Bool() val debugOption = Bool() } val io = new Bundle { val out = new Out } io.out.debug := true.B io.out.debugOption := DontCare This indicates that the signal io.out.debugOption is intentionally not driven and firrtl should not issue a “not fully initialized” error for this signal. This can be applied to aggregates as well as individual signals: import chisel3._ class ModWithVec extends Module { // ... val nElements = 5 val io = IO(new Bundle { val outs = Output(Vec(nElements, Bool())) }) io.outs &lt;&gt; DontCare // ... } class TrivialInterface extends Bundle { val in = Input(Bool()) val out = Output(Bool()) } class ModWithTrivalInterface extends Module { // ... val io = IO(new TrivialInterface) io &lt;&gt; DontCare // ... } This feature is controlled by CompileOptions.explicitInvalidate and is set to false in NotStrict (Chisel2 compatibility mode), and true in Strict mode. You can selectively enable this for Chisel2 compatibility mode by providing your own explicit compileOptions, either for a group of Modules (via inheritance): abstract class ExplicitInvalidateModule extends Module()(chisel3.ExplicitCompileOptions.NotStrict.copy(explicitInvalidate = true)) or on a per-Module basis: class MyModule extends Module { override val compileOptions = chisel3.ExplicitCompileOptions.NotStrict.copy(explicitInvalidate = true) val io = IO(new Bundle { /* ... */ } ) // ... } Or conversely, disable this stricter checking (which is now the default in pure chisel3): abstract class ImplicitInvalidateModule extends Module()(chisel3.ExplicitCompileOptions.Strict.copy(explicitInvalidate = false)) or on a per-Module basis: class MyModule extends Module { override val compileOptions = chisel3.ExplicitCompileOptions.Strict.copy(explicitInvalidate = false) val io = IO(new Bundle { /* ... */ } ) // ... } Please see the corresponding API tests for examples. Determining the unconnected element I have an interface with 42 wires. Which one of them is unconnected? The firrtl error message should contain something like: firrtl.passes.CheckInitialization$RefNotInitializedException: @[:@6.4] : [module Router] Reference io is not fully initialized. @[Decoupled.scala 38:19:@48.12] : node _GEN_23 = mux(and(UInt&lt;1&gt;(\"h1\"), eq(UInt&lt;2&gt;(\"h3\"), _T_84)), _GEN_2, VOID) @[Decoupled.scala 38:19:@48.12] @[Router.scala 78:30:@44.10] : node _GEN_36 = mux(_GEN_0.ready, _GEN_23, VOID) @[Router.scala 78:30:@44.10] @[Router.scala 75:26:@39.8] : node _GEN_54 = mux(io.in.valid, _GEN_36, VOID) @[Router.scala 75:26:@39.8] @[Router.scala 70:50:@27.6] : node _GEN_76 = mux(io.load_routing_table_request.valid, VOID, _GEN_54) @[Router.scala 70:50:@27.6] @[Router.scala 65:85:@19.4] : node _GEN_102 = mux(_T_62, VOID, _GEN_76) @[Router.scala 65:85:@19.4] : io.outs[3].bits.body &lt;= _GEN_102 The first line is the initial error report. Successive lines, indented and beginning with source line information indicate connections involving the problematic signal. Unfortunately, if these are when conditions involving muxes, they may be difficult to decipher. The last line of the group, indented and beginning with a : should indicate the uninitialized signal component. This example (from the Router tutorial) was produced when the output queue bits were not initialized. The old code was: io.outs.foreach { out =&gt; out.noenq() } which initialized the queue’s valid bit, but did not initialize the actual output values. The fix was: io.outs.foreach { out =&gt; out.bits := 0.U.asTypeOf(out.bits) out.noenq() }"
    } ,    
    {
      "title": "Upgrading From Scala 2.11",
      "url": "/chisel3/docs/appendix/upgrading-from-scala-2-11.html",
      "content": "Upgrading From Scala 2.11 to 2.12 As the latest (and probably last) release of Scala 2.11 (2.11.12) was released on 2 November 2017, the time has come to deprecate support for Scala 2.11. Chisel 3.4 is the last version of Chisel that will support Scala 2.11, so users should upgrade to Scala 2.12 This document is intended to help guide Chisel users through this process; both the “Why?” and the “How?”. Scala Versioning Scala versions have the following structure: 2.X.Y where X is the major version and Y is the minor version. Note that while we keep the leading 2 constant, there is a project, Dotty, that is slated to become Scala 3. Scala maintains both source and binary compatiblity between minor versions, but not between major versions. Binary compatibility is defined at the level of the Java Byte Code (the .class or .jar files compiled from .scala). This means that Scala projects that support multiple major versions of Scala must be compiled and published for each supported version. When publishing artifacts to Maven repositories, this manifests as an appendix on the Artifact ID. Taking Chisel v3.3.2 as an example, the “Artifact ID” is “chisel3_2.12” for Scala 2.12, and “chisel3_2.11” for Scala 2.11. For more information, see the documentation on the Scala website: Binary Compatibility of Scala Releases Binary Compatibility for Library Authoers How to Upgrade For most users, this is as simple as changing the scalaVersion field in your build.sbt: scalaVersion := \"2.11.12\" Becomes scalaVersion := \"2.12.12\" Now, the next time you run SBT, it will be using the Scala 2.12 version of Chisel 3 (as well as any other dependencies you have). Common Issues As mentioned in the previous section, Scala does not maintain source compatibilty between major versions. Put another way, sometimes they break things in backwards incompatible ways. This section includes some common issues that Chisel users run into and how to fix them. For complete information about changes, please see the release notes for Scala 2.12.0. Value is not a member of chisel3.Bundle The most common problem for Chisel users upgrading from Scala 2.11 to 2.12 is a change in Scala type inference. This usually occurs in the context of io Bundles in Modules, given: class Foo extends Module { val io = IO(new Bundle { val in = Input(Bool()) val out = Output(Bool()) }) io.out := ~io.in } You may see an error that says somethign like “value out is not a member of chisel3.Bundle”: [error] /workspace/src/main/scala/gcd/Foo.scala:9:6: value out is not a member of chisel3.Bundle [error] io.out := ~io.in [error] ^ [error] /workspace/src/main/scala/gcd/Foo.scala:9:17: value in is not a member of chisel3.Bundle [error] io.out := ~io.in [error] ^ [error] two errors found This can be worked around by adding -Xsource:2.11 to your scalacOptions. This is most commonly set in your build.sbt. For an example, see the chisel-template’s build.sbt."
    } ,    
    {
      "title": "Versioning",
      "url": "/chisel3/docs/appendix/versioning.html",
      "content": "Chisel Project Versioning Chisel and related projects follow a versioning scheme similar to PVP. Project versions are of the form A.B.C where A.B specifies the Major version and C specifies the Minor version. Projects maintain binary compatibility between minor versions of the same major version. For example, a project compiled against Chisel3 version 3.4.0 can be used with Chisel3 version 3.4.2 or 3.4.15 without recompilation. Compatible Versions Historically, due to a mistake in versioning with chisel-iotesters as well as some projects originating later than others, the compatible versions of Chisel-related projects has not been obvious. We are taking steps to improve the situation by bringing the major versions more in line (the B part in A.B.C), but the inconsistencies remain in previously published versions. Please use the following table to determine which versions of the related projects are compatible. In particular, versions of projects in this table were compiled against the version of any dependencies listed in the same row. For example, chisel-iotesters version 1.4 was compiled against chisel3 version 3.3. chisel3 chiseltest chisel-iotesters firrtl treadle diagrammer firrtl-interpreter2 3.4 0.3 1.5 1.4 1.3 1.3 1.4 3.3 0.2 1.4 1.3 1.2 1.2 1.3 3.2 0.11 1.3 1.2 1.1 1.1 1.2 3.1 - 1.2 1.1 1.0 1.0 1.1 3.0 - 1.1 1.0 -3 - 1.0 1 chiseltest 0.1 was published under artifact name chisel-testers2 (0.2 was published under both artifact names) 2 Replaced by Treadle, in maintenance mode only since version 1.1 3 Treadle was preceded by the firrtl-interpreter"
    } ,    
    {
      "title": "Width Inference",
      "url": "/chisel3/docs/explanations/width-inference.html",
      "content": "Width Inference Chisel provides bit width inference to reduce design effort. Users are encouraged to manually specify widths of ports and registers to prevent any surprises, but otherwise unspecified widths will be inferred by the Firrtl compiler. For all circuit components declared with unspecified widths, the FIRRTL compiler will infer the minimum possible width that maintains the legality of all its incoming connections. Implicit here is that inference is done in a right to left fashion in the sense of an assignment statement in chisel, i.e. from the left hand side from the right hand side. If a component has no incoming connections, and the width is unspecified, then an error is thrown to indicate that the width could not be inferred. For module input ports with unspecified widths, the inferred width is the minimum possible width that maintains the legality of all incoming connections to all instantiations of the module. The width of a ground-typed multiplexor expression is the maximum of its two corresponding input widths. For multiplexing aggregate-typed expressions, the resulting widths of each leaf subelement is the maximum of its corresponding two input leaf subelement widths. The width of a conditionally valid expression is the width of its input expression. For the full formal description see the Firrtl Spec. Hardware operators have output widths as defined by the following set of rules: operation bit width z = x + y or z = x +% y w(z) = max(w(x), w(y)) z = x +&amp; y w(z) = max(w(x), w(y)) + 1 z = x - y or z = x -% y w(z) = max(w(x), w(y)) z = x -&amp; y w(z) = max(w(x), w(y)) + 1 z = x &amp; y w(z) = max(w(x), w(y)) z = Mux(c, x, y) w(z) = max(w(x), w(y)) z = w * y w(z) = w(x) + w(y) z = x &lt;&lt; n w(z) = w(x) + maxNum(n) z = x &gt;&gt; n w(z) = w(x) - minNum(n) z = Cat(x, y) w(z) = w(x) + w(y) z = Fill(n, x) w(z) = w(x) * maxNum(n) where for instance w(z) is the bit width of wire z, and the &amp; rule applies to all bitwise logical operations. Given a path of connections that begins with an unspecified width element (most commonly a top-level input), then the compiler will throw an exception indicating a certain width was uninferrable. A common “gotcha” comes from truncating addition and subtraction with the operators + and -. Users who want the result to maintain the full, expanded precision of the addition or subtraction should use the expanding operators +&amp; and -&amp;. The default truncating operation comes from Chisel’s history as a microprocessor design language."
    } ,          
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
